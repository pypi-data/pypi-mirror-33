import sys
from pathlib import Path

from click import ClickException
from jinja2 import Environment

from .configuration import get_sphinx_configuration
from .extensions import get_extensions
from .project_metadata import NoUniqueModuleError, ProjectMetadata

GENERATED_TEXT = "THIS FILE IS AUTOMATICALLY GENERATED BY FLINX. "
"MANUAL CHANGES WILL BE LOST."

env = Environment()
env.filters['repr'] = repr
poject_relpath = Path('..')
env.filters['project_rel'] = lambda s: str(poject_relpath / s)

TEMPLATE_DIR = Path(__file__).parent / 'templates'
conf_tpl = env.from_string((TEMPLATE_DIR / 'conf.py.tpl').read_text())
index_tpl = env.from_string((TEMPLATE_DIR / 'index.rst.tpl').read_text())


class NonGeneratedFileExists(ClickException):
    """An exception that indicates a non-generate file exists.

    An exception for ``write_template_files`` to raise when a writing a file
    would replace a non - generated file.
    """

    @property
    def path(self):
        """Return the pathname of the file, as a Path."""
        return self.args[0]

    def format_message(self):
        """Return the message for click to display."""
        return "won't overwrite {}; aborting. " \
            "Use --force to overwrite.".format(str(self.path))


def write_template_files(output_dir,
                         force=True,
                         include_generated_warning=True,
                         unless_exists=False,
                         verbose=True):
    """Generate the ``conf.py`` and ``README.rst`` files."""
    index_path = output_dir / 'index.rst'
    conf_path = output_dir / 'conf.py'
    overwritten_files = [path for path in (conf_path, index_path)
                         if path.exists() and GENERATED_TEXT not in path.read_text()]
    if overwritten_files and not force:
        if unless_exists:
            return
        raise NonGeneratedFileExists(overwritten_files[0])

    output_dir.mkdir(parents=True, exist_ok=True)
    metadata = ProjectMetadata.from_dir('.')
    config = get_sphinx_configuration('.')
    try:
        metadata['name']  # for effect
    except NoUniqueModuleError as e:
        sys.stderr.write("{}\n".format(e))
        sys.exit(1)
    generated_text = GENERATED_TEXT if include_generated_warning else None
    index_text = index_tpl.render(
        readme=metadata['readme'],
        module_name=metadata['module'],
        generated_text=generated_text,
    )
    index_path.write_text(index_text)
    if verbose:
        print('Wrote', index_path)

    author = metadata['author']
    copyright_year = metadata['date']
    config['extensions'] = get_extensions(config)
    conf_text = conf_tpl.render(
        module_path='..',
        project=metadata['name'],
        copyright=f'{copyright_year}, {author}',
        author=author,
        version=metadata['version'],
        source_suffix=['.rst'],
        master_basename='index',
        generated_text=generated_text,
        config=config.items(),
    )
    conf_path.write_text(conf_text)
    if verbose:
        print('Wrote', conf_path)
    return conf_path
