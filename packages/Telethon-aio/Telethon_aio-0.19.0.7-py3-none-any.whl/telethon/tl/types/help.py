"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeAccessPointRule, TypeChat, TypeBool, TypeRecentMeUrl, TypeUser



class AppUpdate(TLObject):
    CONSTRUCTOR_ID = 0x8987f311
    SUBCLASS_OF_ID = 0x5897069e

    def __init__(self, id, critical, url, text):
        """
        :param int id:
        :param TypeBool critical:
        :param str url:
        :param str text:

        Constructor for help.AppUpdate: Instance of either AppUpdate, NoAppUpdate.
        """
        super().__init__()

        self.id = id  # type: int
        self.critical = critical  # type: TypeBool
        self.url = url  # type: str
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'AppUpdate',
            'id': self.id,
            'critical': self.critical,
            'url': self.url,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xf3\x87\x89',
            struct.pack('<i', self.id),
            b'\xb5ur\x99' if self.critical else b'7\x97y\xbc',
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _critical = reader.tgread_bool()
        _url = reader.tgread_string()
        _text = reader.tgread_string()
        return cls(id=_id, critical=_critical, url=_url, text=_text)


class ConfigSimple(TLObject):
    CONSTRUCTOR_ID = 0x5a592a6c
    SUBCLASS_OF_ID = 0x29183ac4

    def __init__(self, date, expires, rules):
        """
        :param Optional[datetime] date:
        :param Optional[datetime] expires:
        :param List[TypeAccessPointRule] rules:

        Constructor for help.ConfigSimple: Instance of ConfigSimple.
        """
        super().__init__()

        self.date = date  # type: Optional[datetime]
        self.expires = expires  # type: Optional[datetime]
        self.rules = rules  # type: List[TypeAccessPointRule]

    def to_dict(self):
        return {
            '_': 'ConfigSimple',
            'date': self.date,
            'expires': self.expires,
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]
        }

    def __bytes__(self):
        return b''.join((
            b'l*YZ',
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_datetime(self.expires),
            struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @classmethod
    def from_reader(cls, reader):
        _date = reader.tgread_date()
        _expires = reader.tgread_date()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return cls(date=_date, expires=_expires, rules=_rules)


class InviteText(TLObject):
    CONSTRUCTOR_ID = 0x18cb9f78
    SUBCLASS_OF_ID = 0xcf70aa35

    def __init__(self, message):
        """
        :param str message:

        Constructor for help.InviteText: Instance of InviteText.
        """
        super().__init__()

        self.message = message  # type: str

    def to_dict(self):
        return {
            '_': 'InviteText',
            'message': self.message
        }

    def __bytes__(self):
        return b''.join((
            b'x\x9f\xcb\x18',
            TLObject.serialize_bytes(self.message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_string()
        return cls(message=_message)


class NoAppUpdate(TLObject):
    CONSTRUCTOR_ID = 0xc45a6536
    SUBCLASS_OF_ID = 0x5897069e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'NoAppUpdate'
        }

    def __bytes__(self):
        return b''.join((
            b'6eZ\xc4',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class RecentMeUrls(TLObject):
    CONSTRUCTOR_ID = 0xe0310d7
    SUBCLASS_OF_ID = 0xf269c477

    def __init__(self, urls, chats, users):
        """
        :param List[TypeRecentMeUrl] urls:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for help.RecentMeUrls: Instance of RecentMeUrls.
        """
        super().__init__()

        self.urls = urls  # type: List[TypeRecentMeUrl]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'RecentMeUrls',
            'urls': [] if self.urls is None else [None if x is None else x.to_dict() for x in self.urls],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7\x10\x03\x0e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.urls)),b''.join(bytes(x) for x in self.urls),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _urls = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _urls.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(urls=_urls, chats=_chats, users=_users)


class Support(TLObject):
    CONSTRUCTOR_ID = 0x17c6b5f6
    SUBCLASS_OF_ID = 0x7159bceb

    def __init__(self, phone_number, user):
        """
        :param str phone_number:
        :param TypeUser user:

        Constructor for help.Support: Instance of Support.
        """
        super().__init__()

        self.phone_number = phone_number  # type: str
        self.user = user  # type: TypeUser

    def to_dict(self):
        return {
            '_': 'Support',
            'phone_number': self.phone_number,
            'user': None if self.user is None else self.user.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xb5\xc6\x17',
            TLObject.serialize_bytes(self.phone_number),
            bytes(self.user),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _user = reader.tgread_object()
        return cls(phone_number=_phone_number, user=_user)


class TermsOfService(TLObject):
    CONSTRUCTOR_ID = 0xf1ee3e90
    SUBCLASS_OF_ID = 0x20ee8312

    def __init__(self, text):
        """
        :param str text:

        Constructor for help.TermsOfService: Instance of TermsOfService.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'TermsOfService',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\x90>\xee\xf1',
            TLObject.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)

