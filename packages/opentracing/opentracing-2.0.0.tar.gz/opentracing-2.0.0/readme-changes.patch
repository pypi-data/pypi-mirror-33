diff --git a/README.rst b/README.rst
index 5d216db..d45a7b6 100644
--- a/README.rst
+++ b/README.rst
@@ -59,7 +59,7 @@ Somewhere in your server's request handler code:
        # store span in some request-local storage using Tracer.scope_manager,
        # using the returned `Scope` as Context Manager to ensure
        # `Span` will be cleared and (in this case) `Span.finish()` be called.
-       with tracer.scope_manager.activate(span, True) as scope:
+       with tracer.scope_manager.activate(span, finish_on_close=True) as scope:
            # actual business logic
            handle_request_for_real(request)
 
@@ -104,21 +104,17 @@ Somewhere in your service that's about to make an outgoing call:
    from opentracing_instrumentation import request_context
 
    # create and serialize a child span and use it as context manager
-   with before_http_request(
-       request=out_request,
-       current_span_extractor=request_context.get_current_span):
-
+   # the currently active span stored in some request-local storage
+   # will automatically be used as the parent.
+   span = before_http_request(request=out_request)
+   with opentracing.tracer.scope_manager.activate(span, finish_on_close=True):
        # actual call
        return urllib2.urlopen(request)
 
 
-   def before_http_request(request, current_span_extractor):
+   def before_http_request(request):
        op = request.operation
-       parent_span = current_span_extractor()
-       outbound_span = opentracing.tracer.start_span(
-           operation_name=op,
-           child_of=parent_span
-       )
+       outbound_span = opentracing.tracer.start_span(operation_name=op)
 
        outbound_span.set_tag('http.url', request.full_url)
        service_name = request.service_name
@@ -159,30 +155,29 @@ another task or thread, but not ``Scope``.
 The common case starts a ``Scope`` that's automatically registered for intra-process
 propagation via ``ScopeManager``.
 
-Note that ``start_active_span('...', True)`` finishes the span on ``Scope.close()``
-(``start_active_span('...', False)`` does not finish it, in contrast).
+Note that ``start_active_span('...')`` automatically finishes the span on ``Scope.close()``
+(``start_active_span('...', finish_on_close=False)`` does not finish it, in contrast).
 
 .. code-block:: python
 
        # Manual activation of the Span.
        span = tracer.start_span(operation_name='someWork')
-       with tracer.scope_manager.activate(span, True) as scope:
+       with tracer.scope_manager.activate(span, finish_on_close=True) as scope:
            # Do things.
 
        # Automatic activation of the Span.
-       # finish_on_close is a required parameter.
-       with tracer.start_active_span('someWork', finish_on_close=True) as scope:
+       with tracer.start_active_span('someWork') as scope:
            # Do things.
 
        # Handling done through a try construct:
        span = tracer.start_span(operation_name='someWork')
-       scope = tracer.scope_manager.activate(span, True)
+       scope = tracer.scope_manager.activate(span, finish_on_close=True)
        try:
            # Do things.
        except Exception as e:
            scope.set_tag('error', '...')
        finally:
-           scope.finish()
+           scope.close()
 
 **If there is a Scope, it will act as the parent to any newly started Span** unless
 the programmer passes ``ignore_active_span=True`` at ``start_span()``/``start_active_span()``
