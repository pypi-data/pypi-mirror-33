{"version":3,"sources":["core/util/templating.ts"],"names":[],"mappings":"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","file":"templating.js","sourcesContent":["import {sprintf} from \"sprintf-js\"\nimport * as Numbro from \"numbro\"\nimport tz = require(\"timezone\")\n\nimport {escape} from \"./string\"\nimport {isNumber, isString, isArray, isTypedArray} from \"./types\"\n\nimport {ColumnarDataSource} from \"models/sources/columnar_data_source\"\nimport {ImageIndex} from \"../../models/glyphs/image\"\nimport {CustomJSHover} from 'models/tools/inspectors/customjs_hover'\n\nexport type FormatterType = \"numeral\" | \"printf\" | \"datetime\"\nexport type FormatterSpec = CustomJSHover | FormatterType\nexport type Formatters = {[key: string]: FormatterSpec}\nexport type FormatterFunc = (value:any, format:string, special_vars: Vars) => string\nexport type Index = number | ImageIndex\nexport type Vars = {[key: string]: any}\n\nexport const DEFAULT_FORMATTERS = {\n  \"numeral\"  : function(value:any, format:string, _special_vars: Vars) { return Numbro.format(value, format) },\n  \"datetime\" : function(value:any, format:string, _special_vars: Vars) { return tz(value, format)            },\n  \"printf\"   : function(value:any, format:string, _special_vars: Vars) { return sprintf(format, value)       },\n}\n\nexport function basic_formatter(value:any, _format:string, _special_vars: Vars): string {\n  if (isNumber(value)) {\n    const format = (() => {\n      switch (false) {\n        case Math.floor(value) != value:\n          return \"%d\"\n        case !(Math.abs(value) > 0.1) || !(Math.abs(value) < 1000):\n          return \"%0.3f\"\n        default:\n          return \"%0.3e\"\n      }\n    })()\n\n    return sprintf(format, value)\n  }\n\n  else\n    return `${value}`  // get strings for categorical types\n}\n\nexport function get_formatter(name: string, raw_spec: string, format?: string, formatters?: Formatters): FormatterFunc {\n  // no format, use default built in formatter\n  if (format == null)\n    return basic_formatter\n\n  // format spec in the formatters dict, use that\n  if (formatters != null && (name in formatters || raw_spec in formatters)) {\n\n    // some day (Bokeh 2.0) we can get rid of the check for name, and just check the raw spec\n    // keep it now for compatibility but do not demonstrate it anywhere\n    const key: string = raw_spec in formatters ? raw_spec : name\n    const formatter = formatters[key]\n\n    if (isString(formatter)) {\n      if (formatter in DEFAULT_FORMATTERS)\n        return DEFAULT_FORMATTERS[formatter]\n      else\n        throw new Error(`Unknown tooltip field formatter type '${formatter}'`)\n    }\n\n    return function(value: any, format: string, special_vars: Vars) : string {\n      return formatter.format(value, format, special_vars)\n    }\n  }\n\n  // otherwise use \"numeral\" as default\n  return DEFAULT_FORMATTERS[\"numeral\"]\n\n}\n\nexport function get_value(name: string, data_source: ColumnarDataSource, i: Index, special_vars: Vars) {\n\n  if (name[0] == \"$\") {\n    if (name.substring(1) in special_vars)\n      return special_vars[name.substring(1)]\n    else\n      throw new Error(`Unknown special variable '${name}'`)\n  }\n\n  const column = data_source.get_column(name)\n\n  // missing column\n  if (column == null)\n    return null\n\n  // typical (non-image) index\n  if (isNumber(i))\n    return column[i]\n\n  // image index\n  const data = column[i.index]\n  if (isTypedArray(data) || isArray(data)) {\n\n    // inspect array of arrays\n    if (isArray(data[0])) {\n      const row: any = data[i.dim2]\n      return row[i.dim1]\n    }\n\n    // inspect flat array\n    else\n      return data[i.flat_index]\n\n  }\n\n  // inspect per-image scalar data\n  else\n    return data\n\n}\n\nexport function replace_placeholders(str: string, data_source: ColumnarDataSource, i: Index, formatters?: Formatters, special_vars: Vars = {}): string {\n\n  // this extracts the $x, @x, @{x} without any trailing {format}\n  const raw_spec = str.replace(/(?:^|[^@])([@|\\$](?:\\w+|{[^{}]+}))(?:{[^{}]+})?/g, (_match, raw_spec, _format) => `${raw_spec}`)\n\n  // this prepends special vars with \"@\", e.g \"$x\" becomes \"@$x\", so subsequent processing is simpler\n  str = str.replace(/(^|[^\\$])\\$(\\w+)/g, (_match, prefix, name) => `${prefix}@$${name}`)\n\n  str = str.replace(/(^|[^@])@(?:(\\$?\\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, (_match, prefix, name, long_name, format) => {\n\n    name = long_name != null ? long_name : name\n\n    const value = get_value(name, data_source, i, special_vars)\n\n    // missing value, return ???\n    if (value == null)\n      return `${prefix}${escape(\"???\")}`\n\n    // 'safe' format, return the value as-is\n    if (format == 'safe')\n     return `${prefix}${value}`\n\n    // format and escape everything else\n    const formatter = get_formatter(name, raw_spec, format, formatters)\n    return `${prefix}${escape(formatter(value, format, special_vars))}`\n\n  })\n\n  return str\n\n}\n"]}