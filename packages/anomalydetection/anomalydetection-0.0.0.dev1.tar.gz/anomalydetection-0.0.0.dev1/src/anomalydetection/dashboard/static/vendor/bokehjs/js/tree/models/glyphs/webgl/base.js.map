{"version":3,"sources":["models/glyphs/webgl/base.ts"],"names":[],"mappings":"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","file":"base.js","sourcesContent":["// This module implements the Base GL Glyph and some utilities\nimport {Program, VertexBuffer} from \"gloo2\"\nimport {Arrayable} from \"core/types\"\nimport {color2rgba} from \"core/util/color\"\nimport {Context2d} from \"core/util/canvas\"\nimport {logger} from \"core/logging\"\nimport {GlyphView} from \"../glyph\"\n\nexport abstract class BaseGLGlyph {\n\n  protected nvertices: number = 0\n  protected size_changed: boolean = false\n  protected data_changed: boolean = false\n  protected visuals_changed: boolean = false\n\n  constructor(readonly gl: WebGLRenderingContext, readonly glyph: GlyphView) {\n    this.init()\n  }\n\n  protected abstract init(): void\n\n  set_data_changed(n: number): void {\n    if (n != this.nvertices) {\n      this.nvertices = n\n      this.size_changed = true\n    }\n\n    this.data_changed = true\n  }\n\n  set_visuals_changed(): void {\n    this.visuals_changed = true\n  }\n\n  render(_ctx: Context2d, indices: number[], mainglyph: GlyphView): boolean {\n    // Get transform\n    const [a, b, c] = [0, 1, 2]\n    let wx = 1   // Weights to scale our vectors\n    let wy = 1\n    let [dx, dy] = this.glyph.renderer.map_to_screen([a*wx, b*wx, c*wx], [a*wy, b*wy, c*wy])\n    if (isNaN(dx[0] + dx[1] + dx[2] + dy[0] + dy[1] + dy[2])) {\n      logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`)\n      return false\n    }\n    // Try again, but with weighs so we're looking at ~100 in screen coordinates\n    wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12)\n    wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12)\n    ;[dx, dy] = this.glyph.renderer.map_to_screen([a*wx, b*wx, c*wx], [a*wy, b*wy, c*wy])\n    // Test how linear it is\n    if ((Math.abs((dx[1] - dx[0]) - (dx[2] - dx[1])) > 1e-6) ||\n        (Math.abs((dy[1] - dy[0]) - (dy[2] - dy[1])) > 1e-6)) {\n      logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`)\n      return false\n    }\n    const [sx, sy] = [(dx[1]-dx[0]) / wx, (dy[1]-dy[0]) / wy]\n    const {width, height} = this.glyph.renderer.plot_view.gl!.canvas\n    const trans = {\n      pixel_ratio: this.glyph.renderer.plot_view.canvas.pixel_ratio,  // pass pixel_ratio to webgl\n      width: width, height: height,\n      dx: dx[0]/sx, dy: dy[0]/sy, sx, sy,\n    }\n    this.draw(indices, mainglyph, trans)\n    return true\n  }\n\n  abstract draw(indices: number[], mainglyph: any, trans: Transform): void\n}\n\nexport type Transform = {\n  pixel_ratio: number\n  width: number\n  height: number\n  dx: number\n  dy: number\n  sx: number\n  sy: number\n}\n\nexport function line_width(width: number): number {\n  // Increase small values to make it more similar to canvas\n  if (width < 2) {\n    width = Math.sqrt(width*2)\n  }\n  return width\n}\n\nexport function fill_array_with_float(n: number, val: number): Float32Array {\n  const a = new Float32Array(n)\n  for (let i = 0, end = n; i < end; i++) {\n    a[i] = val\n  }\n  return a\n}\n\nexport function fill_array_with_vec(n: number, m: number, val: Arrayable<number>): Float32Array {\n  const a = new Float32Array(n*m)\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      a[i*m + j] = val[j]\n    }\n  }\n  return a\n}\n\nexport function visual_prop_is_singular(visual: any, propname: string): boolean {\n  // This touches the internals of the visual, so we limit use in this function\n  // See renderer.ts:cache_select() for similar code\n  return visual[propname].spec.value !== undefined\n}\n\nexport function attach_float(prog: Program, vbo: VertexBuffer & {used?: boolean}, att_name: string, n: number, visual: any, name: string): void {\n  // Attach a float attribute to the program. Use singleton value if we can,\n  // otherwise use VBO to apply array.\n  if (!visual.doit) {\n    vbo.used = false\n    prog.set_attribute(att_name, 'float', [0])\n  } else if (visual_prop_is_singular(visual, name)) {\n    vbo.used = false\n    prog.set_attribute(att_name, 'float', visual[name].value())\n  } else {\n    vbo.used = true\n    const a = new Float32Array(visual.cache[name + '_array'])\n    vbo.set_size(n*4)\n    vbo.set_data(0, a)\n    prog.set_attribute(att_name, 'float', vbo)\n  }\n}\n\nexport function attach_color(prog: Program, vbo: VertexBuffer & {used?: boolean}, att_name: string, n: number, visual: any, prefix: string): void {\n  // Attach the color attribute to the program. If there's just one color,\n  // then use this single color for all vertices (no VBO). Otherwise we\n  // create an array and upload that to the VBO, which we attahce to the prog.\n  let rgba\n  const m = 4\n  const colorname = prefix + '_color'\n  const alphaname = prefix + '_alpha'\n\n  if (!visual.doit) {\n    // Don't draw (draw transparent)\n    vbo.used = false\n    prog.set_attribute(att_name, 'vec4', [0,0,0,0])\n  } else if (visual_prop_is_singular(visual, colorname) && visual_prop_is_singular(visual, alphaname)) {\n    // Nice and simple; both color and alpha are singular\n    vbo.used = false\n    rgba = color2rgba(visual[colorname].value(), visual[alphaname].value())\n    prog.set_attribute(att_name, 'vec4', rgba)\n  } else {\n    // Use vbo; we need an array for both the color and the alpha\n    let alphas, colors\n    vbo.used = true\n    // Get array of colors\n    if (visual_prop_is_singular(visual, colorname)) {\n      colors = ((() => {\n        const result = []\n        for (let i = 0, end = n; i < end; i++) {\n          result.push(visual[colorname].value())\n        }\n        return result\n      })())\n    } else {\n      colors = visual.cache[colorname+'_array']\n    }\n    // Get array of alphas\n    if (visual_prop_is_singular(visual, alphaname)) {\n      alphas = fill_array_with_float(n, visual[alphaname].value())\n    } else {\n      alphas = visual.cache[alphaname+'_array']\n    }\n    // Create array of rgbs\n    const a = new Float32Array(n*m)\n    for (let i = 0, end = n; i < end; i++) {\n      rgba = color2rgba(colors[i], alphas[i])\n      for (let j = 0, endj = m; j < endj; j++) {\n        a[(i*m)+j] = rgba[j]\n      }\n    }\n    // Attach vbo\n    vbo.set_size(n*m*4)\n    vbo.set_data(0, a)\n    prog.set_attribute(att_name, 'vec4', vbo)\n  }\n}\n"]}