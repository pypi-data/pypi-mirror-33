{"version":3,"sources":["models/formatters/datetime_tick_formatter.ts"],"names":[],"mappings":"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","file":"datetime_tick_formatter.js","sourcesContent":["import {sprintf} from \"sprintf-js\"\nimport tz = require(\"timezone\")\n\nimport {TickFormatter} from \"./tick_formatter\"\nimport {Axis} from \"../axes/axis\"\nimport {logger} from \"core/logging\"\nimport * as p from \"core/properties\"\nimport {zip, unzip, sortBy} from \"core/util/array\"\nimport {isFunction} from \"core/util/types\"\n\nfunction _us(t: number): number {\n  // From double-precision unix (millisecond) timestamp get\n  // microsecond since last second. Precision seems to run\n  // out around the hundreds of nanoseconds scale, so rounding\n  // to the nearest microsecond should round to a nice\n  // microsecond / millisecond tick.\n  return Math.round(((t / 1000) % 1) * 1000000)\n}\n\nfunction _array(t: number): number[] {\n  return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(e => parseInt(e, 10))\n}\n\nfunction _strftime(t: number, format: string | ((t: number) => string)): string {\n  if (isFunction(format)) {\n    return format(t)\n  } else {\n    // Python's datetime library augments the microsecond directive %f, which is not\n    // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.\n    // Use a regular expression to replace %f directive with microseconds.\n    // TODO: what should we do for negative microsecond strings?\n    const microsecond_replacement_string = sprintf(\"$1%06d\", _us(t))\n    format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string)\n\n    if (format.indexOf(\"%\") == -1) {\n      // timezone seems to ignore any strings without any formatting directives,\n      // and just return the time argument back instead of the string argument.\n      // But we want the string argument, in case a user supplies a format string\n      // which doesn't contain a formatting directive or is only using %f.\n      return format\n    }\n\n    return tz(t, format)\n  }\n}\n\n// Labels of time units, from finest to coarsest.\nconst format_order = [\n  'microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years',\n]\n\nexport namespace DatetimeTickFormatter {\n  export interface Attrs extends TickFormatter.Attrs {\n    microseconds: string[]\n    milliseconds: string[]\n    seconds: string[]\n    minsec: string[]\n    minutes: string[]\n    hourmin: string[]\n    hours: string[]\n    days: string[]\n    months: string[]\n    years: string[]\n  }\n\n  export interface Props extends TickFormatter.Props {}\n}\n\nexport interface DatetimeTickFormatter extends DatetimeTickFormatter.Attrs {}\n\nexport class DatetimeTickFormatter extends TickFormatter {\n\n  properties: DatetimeTickFormatter.Props\n\n  constructor(attrs?: Partial<DatetimeTickFormatter.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = 'DatetimeTickFormatter'\n\n    this.define({\n      microseconds: [ p.Array, ['%fus'] ],\n      milliseconds: [ p.Array, ['%3Nms', '%S.%3Ns'] ],\n      seconds:      [ p.Array, ['%Ss'] ],\n      minsec:       [ p.Array, [':%M:%S'] ],\n      minutes:      [ p.Array, [':%M', '%Mm'] ],\n      hourmin:      [ p.Array, ['%H:%M'] ],\n      hours:        [ p.Array, ['%Hh', '%H:%M'] ],\n      days:         [ p.Array, ['%m/%d', '%a%d'] ],\n      months:       [ p.Array, ['%m/%Y', '%b %Y'] ],\n      years:        [ p.Array, ['%Y'] ],\n    })\n  }\n\n  // Whether or not to strip the leading zeros on tick labels.\n  protected strip_leading_zeros = true\n  protected _width_formats: {[key: string]: [number[], string[]]}\n\n  initialize(): void {\n    super.initialize()\n    // TODO (bev) trigger update on format change\n    this._update_width_formats()\n  }\n\n  protected _update_width_formats(): void {\n    const now = +tz(new Date())\n\n    const _widths = function(fmt_strings: string[]): [number[], string[]] {\n      const sizes = fmt_strings.map((fmt_string) => _strftime(now, fmt_string).length)\n      const sorted = sortBy(zip(sizes, fmt_strings), ([size]) => size)\n      return unzip(sorted)\n    }\n\n    this._width_formats = {\n      microseconds: _widths(this.microseconds),\n      milliseconds: _widths(this.milliseconds),\n      seconds:      _widths(this.seconds),\n      minsec:       _widths(this.minsec),\n      minutes:      _widths(this.minutes),\n      hourmin:      _widths(this.hourmin),\n      hours:        _widths(this.hours),\n      days:         _widths(this.days),\n      months:       _widths(this.months),\n      years:        _widths(this.years),\n    }\n  }\n\n  // FIXME There is some unfortunate flicker when panning/zooming near the\n  // span boundaries.\n  // FIXME Rounding is weird at the 20-us scale and below.\n  protected _get_resolution_str(resolution_secs: number, span_secs: number): string {\n    // Our resolution boundaries should not be round numbers, because we want\n    // them to fall between the possible tick intervals (which *are* round\n    // numbers, as we've worked hard to ensure).  Consequently, we adjust the\n    // resolution upwards a small amount (less than any possible step in\n    // scales) to make the effective boundaries slightly lower.\n    const adjusted_secs = resolution_secs * 1.1\n\n    switch (false) {\n      case !(adjusted_secs < 1e-3):          return \"microseconds\"\n      case !(adjusted_secs < 1.0):           return \"milliseconds\"\n      case !(adjusted_secs < 60):            return span_secs >= 60   ? \"minsec\"  : \"seconds\"\n      case !(adjusted_secs < 3600):          return span_secs >= 3600 ? \"hourmin\" : \"minutes\"\n      case !(adjusted_secs < (24*3600)):     return \"hours\"\n      case !(adjusted_secs < (31*24*3600)):  return \"days\"\n      case !(adjusted_secs < (365*24*3600)): return \"months\"\n      default:                               return \"years\"\n    }\n  }\n\n  doFormat(ticks: number[], _axis: Axis): string[] {\n    // In order to pick the right set of labels, we need to determine\n    // the resolution of the ticks.  We can do this using a ticker if\n    // it's provided, or by computing the resolution from the actual\n    // ticks we've been given.\n    if (ticks.length == 0)\n      return []\n\n    const span = Math.abs(ticks[ticks.length-1] - ticks[0])/1000.0\n    const r = span / (ticks.length - 1)\n    const resol = this._get_resolution_str(r, span)\n\n    const [, [format]] = this._width_formats[resol]\n\n    // Apply the format to the tick values\n    const labels: string[] = []\n    const resol_ndx = format_order.indexOf(resol)\n\n    // This dictionary maps the name of a time resolution (in @format_order)\n    // to its index in a time.localtime() timetuple.  The default is to map\n    // everything to index 0, which is year.  This is not ideal; it might cause\n    // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly\n    // promoted at certain tick resolutions.\n    const time_tuple_ndx_for_resol: {[key: string]: number} = {}\n    for (const fmt of format_order) {\n      time_tuple_ndx_for_resol[fmt] = 0\n    }\n    time_tuple_ndx_for_resol[\"seconds\"] = 5\n    time_tuple_ndx_for_resol[\"minsec\"] = 4\n    time_tuple_ndx_for_resol[\"minutes\"] = 4\n    time_tuple_ndx_for_resol[\"hourmin\"] = 3\n    time_tuple_ndx_for_resol[\"hours\"] = 3\n\n    // As we format each tick, check to see if we are at a boundary of the\n    // next higher unit of time.  If so, replace the current format with one\n    // from that resolution.  This is not the best heuristic in the world,\n    // but it works!  There is some trickiness here due to having to deal\n    // with hybrid formats in a reasonable manner.\n    for (const t of ticks) {\n      let s, tm\n      try {\n        tm = _array(t)\n        s = _strftime(t, format)\n      } catch (error) {\n        logger.warn(`unable to format tick for timestamp value ${t}`)\n        logger.warn(` - ${error}`)\n        labels.push(\"ERR\")\n        continue\n      }\n\n      let hybrid_handled = false\n      let next_ndx = resol_ndx\n\n      // The way to check that we are at the boundary of the next unit of\n      // time is by checking that we have 0 units of the resolution, i.e.\n      // we are at zero minutes, so display hours, or we are at zero seconds,\n      // so display minutes (and if that is zero as well, then display hours).\n      while (tm[time_tuple_ndx_for_resol[format_order[next_ndx]]] == 0) {\n        let next_format\n        next_ndx += 1\n\n        if (next_ndx == format_order.length)\n          break\n\n        if ((resol == \"minsec\" || resol == \"hourmin\") && !hybrid_handled) {\n          if ((resol == \"minsec\" && tm[4] == 0 && tm[5] != 0) || (resol == \"hourmin\" && tm[3] == 0 && tm[4] != 0)) {\n            next_format = this._width_formats[format_order[resol_ndx-1]][1][0]\n            s = _strftime(t, next_format)\n            break\n          } else {\n            hybrid_handled = true\n          }\n        }\n\n        next_format = this._width_formats[format_order[next_ndx]][1][0]\n        s = _strftime(t, next_format)\n      }\n\n      // TODO: should expose this in api. %H, %d, etc use leading zeros and\n      // users might prefer to see them lined up correctly.\n      if (this.strip_leading_zeros) {\n        let ss = s.replace(/^0+/g, \"\")\n        if (ss != s && isNaN(parseInt(ss))) {\n          // If the string can now be parsed as starting with an integer, then\n          // leave all zeros stripped, otherwise start with a zero. Hence:\n          // A label such as '000ms' should leave one zero.\n          // A label such as '001ms' or '0-1ms' should not leave a leading zero.\n          ss = `0${ss}`\n        }\n        labels.push(ss)\n      } else\n        labels.push(s)\n    }\n\n    return labels\n  }\n}\nDatetimeTickFormatter.initClass()\n"]}