{"version":3,"sources":["models/formatters/basic_tick_formatter.ts"],"names":[],"mappings":"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","file":"basic_tick_formatter.js","sourcesContent":["import {TickFormatter} from \"./tick_formatter\"\nimport {Axis} from \"../axes/axis\"\nimport * as p from \"core/properties\"\nimport {isNumber} from \"core/util/types\"\n\nexport namespace BasicTickFormatter {\n  export interface Attrs extends TickFormatter.Attrs {\n    precision: number | \"auto\"\n    use_scientific: boolean\n    power_limit_high: number\n    power_limit_low: number\n  }\n\n  export interface Props extends TickFormatter.Props {}\n}\n\nexport interface BasicTickFormatter extends BasicTickFormatter.Attrs {}\n\nexport class BasicTickFormatter extends TickFormatter {\n\n  properties: BasicTickFormatter.Props\n\n  constructor(attrs?: Partial<BasicTickFormatter.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = 'BasicTickFormatter'\n\n    this.define({\n      precision:        [ p.Any,    'auto' ], // TODO (bev) better\n      use_scientific:   [ p.Bool,   true   ],\n      power_limit_high: [ p.Number, 5      ],\n      power_limit_low:  [ p.Number, -3     ],\n    })\n  }\n\n  protected last_precision: number = 3\n\n  get scientific_limit_low(): number {\n    return Math.pow(10.0, this.power_limit_low)\n  }\n\n  get scientific_limit_high(): number {\n    return Math.pow(10.0, this.power_limit_high)\n  }\n\n  doFormat(ticks: number[], _axis: Axis): string[] {\n    if (ticks.length == 0)\n      return []\n\n    let zero_eps = 0\n    if (ticks.length >= 2)\n      zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000\n\n    let need_sci = false\n    if (this.use_scientific) {\n      for (const tick of ticks) {\n        const tick_abs = Math.abs(tick)\n        if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {\n          need_sci = true\n          break\n        }\n      }\n    }\n\n    const labels: string[] = new Array(ticks.length)\n    const {precision} = this\n\n    if (precision == null || isNumber(precision)) {\n      if (need_sci) {\n        for (let i = 0, end = ticks.length; i < end; i++) {\n          labels[i] = ticks[i].toExponential(precision || undefined)\n        }\n      } else {\n        for (let i = 0, end = ticks.length; i < end; i++) {\n          labels[i] = ticks[i].toFixed(precision || undefined).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\")\n        }\n      }\n    } else {\n      for (let x = this.last_precision, asc = this.last_precision <= 15; asc ? x <= 15 : x >= 15; asc ? x++ : x--) {\n        let is_ok = true\n\n        if (need_sci) {\n          for (let i = 0, end = ticks.length; i < end; i++) {\n            labels[i] = ticks[i].toExponential(x)\n            if (i > 0) {\n              if (labels[i] === labels[i-1]) {\n                is_ok = false\n                break\n              }\n            }\n          }\n          if (is_ok) {\n            break\n          }\n        } else {\n          for (let i = 0, end = ticks.length; i < end; i++) {\n            labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\")\n            if (i > 0) {\n              if (labels[i] == labels[i-1]) {\n                is_ok = false\n                break\n              }\n            }\n          }\n          if (is_ok) {\n            break\n          }\n        }\n\n        if (is_ok) {\n          this.last_precision = x\n          break\n        }\n      }\n    }\n\n    return labels\n  }\n}\nBasicTickFormatter.initClass()\n"]}