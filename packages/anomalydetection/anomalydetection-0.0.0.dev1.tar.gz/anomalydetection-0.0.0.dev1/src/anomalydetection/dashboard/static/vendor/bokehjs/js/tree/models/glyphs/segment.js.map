{"version":3,"sources":["models/glyphs/segment.ts"],"names":[],"mappings":"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","file":"segment.js","sourcesContent":["import {PointGeometry, SpanGeometry} from \"core/geometry\"\nimport * as hittest from \"core/hittest\"\nimport {NumberSpec} from \"core/vectorization\"\nimport {LineMixinVector} from \"core/property_mixins\"\nimport {Line} from \"core/visuals\"\nimport {Arrayable} from \"core/types\"\nimport {IBBox} from \"core/util/bbox\"\nimport {SpatialIndex} from \"core/util/spatial\"\nimport {Context2d} from \"core/util/canvas\"\nimport {Glyph, GlyphView, GlyphData} from \"./glyph\"\nimport {generic_line_legend} from \"./utils\"\nimport {Selection} from \"../selections/selection\"\n\nexport interface SegmentData extends GlyphData {\n  _x0: Arrayable<number>\n  _y0: Arrayable<number>\n  _x1: Arrayable<number>\n  _y1: Arrayable<number>\n\n  sx0: Arrayable<number>\n  sy0: Arrayable<number>\n  sx1: Arrayable<number>\n  sy1: Arrayable<number>\n}\n\nexport interface SegmentView extends SegmentData {}\n\nexport class SegmentView extends GlyphView {\n  model: Segment\n  visuals: Segment.Visuals\n\n  protected _index_data(): SpatialIndex {\n    const points = []\n\n    for (let i = 0, end = this._x0.length; i < end; i++) {\n      const x0 = this._x0[i]\n      const x1 = this._x1[i]\n      const y0 = this._y0[i]\n      const y1 = this._y1[i]\n\n      if (!isNaN(x0 + x1 + y0 + y1)) {\n        points.push({\n          minX: Math.min(x0, x1),\n          minY: Math.min(y0, y1),\n          maxX: Math.max(x0, x1),\n          maxY: Math.max(y0, y1),\n          i,\n        })\n      }\n    }\n\n    return new SpatialIndex(points)\n  }\n\n  protected _render(ctx: Context2d, indices: number[], {sx0, sy0, sx1, sy1}: SegmentData): void {\n    if (this.visuals.line.doit) {\n      for (const i of indices) {\n        if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i]))\n          continue\n\n        ctx.beginPath()\n        ctx.moveTo(sx0[i], sy0[i])\n        ctx.lineTo(sx1[i], sy1[i])\n\n        this.visuals.line.set_vectorize(ctx, i)\n        ctx.stroke()\n      }\n    }\n  }\n\n  protected _hit_point(geometry: PointGeometry): Selection {\n    const {sx, sy} = geometry\n    const point = {x: sx, y: sy}\n\n    const hits = []\n    const lw_voffset = 2; // FIXME: Use maximum of segments line_width/2 instead of magic constant 2\n\n    const [minX, maxX] = this.renderer.xscale.r_invert(sx-lw_voffset, sx+lw_voffset)\n    const [minY, maxY] = this.renderer.yscale.r_invert(sy-lw_voffset, sy+lw_voffset)\n    const candidates = this.index.indices({minX, minY, maxX, maxY})\n\n    for (const i of candidates) {\n      const threshold2 = Math.pow(Math.max(2, this.visuals.line.cache_select('line_width', i) / 2), 2)\n      const p0 = {x: this.sx0[i], y: this.sy0[i]}\n      const p1 = {x: this.sx1[i], y: this.sy1[i]}\n      const dist2 = hittest.dist_to_segment_squared(point, p0, p1)\n      if (dist2 < threshold2)\n        hits.push(i)\n    }\n\n    const result = hittest.create_empty_hit_test_result()\n    result.indices = hits\n    return result\n  }\n\n  protected _hit_span(geometry: SpanGeometry): Selection {\n    const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges\n    const {sx, sy} = geometry\n\n    let v0: Arrayable<number>\n    let v1: Arrayable<number>\n    let val: number\n    if (geometry.direction == 'v') {\n      val = this.renderer.yscale.invert(sy)\n      ;[v0, v1] = [this._y0, this._y1]\n    } else {\n      val = this.renderer.xscale.invert(sx)\n      ;[v0, v1] = [this._x0, this._x1]\n    }\n\n    const hits = []\n\n    const [minX, maxX] = this.renderer.xscale.r_invert(hr.start, hr.end)\n    const [minY, maxY] = this.renderer.yscale.r_invert(vr.start, vr.end)\n    const candidates = this.index.indices({minX, minY, maxX, maxY})\n\n    for (const i of candidates) {\n      if ((v0[i] <= val && val <= v1[i]) || (v1[i] <= val && val <= v0[i]))\n        hits.push(i)\n    }\n\n    const result = hittest.create_empty_hit_test_result()\n    result.indices = hits\n    return result\n  }\n\n  scenterx(i: number): number {\n    return (this.sx0[i] + this.sx1[i])/2\n  }\n\n  scentery(i: number): number {\n    return (this.sy0[i] + this.sy1[i])/2\n  }\n\n  draw_legend_for_index(ctx: Context2d, bbox: IBBox, index: number): void {\n    generic_line_legend(this.visuals, ctx, bbox, index)\n  }\n}\n\nexport namespace Segment {\n  export interface Mixins extends LineMixinVector {}\n\n  export interface Attrs extends Glyph.Attrs, Mixins {\n    x0: NumberSpec\n    y0: NumberSpec\n    x1: NumberSpec\n    y1: NumberSpec\n  }\n\n  export interface Props extends Glyph.Props {}\n\n  export interface Visuals extends Glyph.Visuals {\n    line: Line\n  }\n}\n\nexport interface Segment extends Segment.Attrs {}\n\nexport class Segment extends Glyph {\n\n  properties: Segment.Props\n\n  constructor(attrs?: Partial<Segment.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = 'Segment'\n    this.prototype.default_view = SegmentView\n\n    this.coords([['x0', 'y0'], ['x1', 'y1']])\n    this.mixins(['line'])\n  }\n}\nSegment.initClass()\n"]}