{"version":3,"sources":["base.ts"],"names":[],"mappings":";;AAAA,uCAAwC;AACxC,6CAAwC;AAM3B,QAAA,SAAS,GAAqC,EAAE,CAAA;AAC7D,IAAM,WAAW,GAAqC,cAAK,CAAC,MAAM,CAAQ,CAAA;AAU7D,QAAA,MAAM,GAAG,CAAC,UAAC,IAAY;IAClC,IAAM,KAAK,GAAG,iBAAS,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAA;IAElD,IAAI,KAAK,IAAI,IAAI,EAAE;QACjB,MAAM,IAAI,KAAK,CAAC,YAAU,IAAI,qIAC8C,CAAC,CAAA;KAC9E;IAED,OAAO,KAAK,CAAA;AACd,CAAC,CAAW,CAAA;AAEZ,cAAM,CAAC,QAAQ,GAAG,UAAC,IAAI,EAAE,KAAK;IAC5B,iBAAS,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;AACzB,CAAC,CAAA;AAED,cAAM,CAAC,UAAU,GAAG,UAAC,IAAI;IACvB,OAAO,iBAAS,CAAC,IAAI,CAAC,CAAA;AACxB,CAAC,CAAA;AAED,cAAM,CAAC,eAAe,GAAG,UAAC,MAAM,EAAE,KAAa,EAAE,OAAQ;IAAvB,sBAAA,EAAA,aAAa;IAC7C,IAAI,MAAM,IAAI,IAAI;QAChB,OAAM;IAER,KAAK,IAAM,MAAI,IAAI,MAAM,EAAE;QACzB,IAAM,KAAK,GAAG,MAAM,CAAC,MAAI,CAAC,CAAA;QAE1B,IAAI,KAAK,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,MAAI,CAAC;YAC5C,WAAW,CAAC,MAAI,CAAC,GAAG,KAAK,CAAA;aACtB,IAAI,OAAO,IAAI,IAAI;YACtB,OAAO,CAAC,MAAI,CAAC,CAAA;;YAEb,OAAO,CAAC,IAAI,CAAC,YAAU,MAAI,6BAA0B,CAAC,CAAA;KACzD;AACH,CAAC,CAAA;AAEY,QAAA,eAAe,GAAG,cAAM,CAAC,eAAe,CAAA;AAErD,cAAM,CAAC,gBAAgB,GAAG,cAAM,OAAA,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAxB,CAAwB,CAAA;AAExD,2DAA2D;AAC3D,6DAA6D;AAC7D,kEAAkE;AAClE,eAAe;AACF,QAAA,KAAK,GAA0B,EAAE,CAAA","file":"base.js","sourcesContent":["import * as models from \"./models/index\"\nimport {clone} from \"./core/util/object\"\nimport {HasProps} from \"./core/has_props\"\nimport {Class} from \"./core/class\"\n\nexport type View = any\n\nexport const overrides: {[key: string]: Class<HasProps>} = {}\nconst _all_models: {[key: string]: Class<HasProps>} = clone(models) as any\n\nexport interface Models {\n  (name: string): Class<HasProps>\n  register(name: string, model: Class<HasProps>): void\n  unregister(name: string): void\n  register_models(models: {[key: string]: Class<HasProps>} | null | undefined, force?: boolean, errorFn?: (name: string) => void): void\n  registered_names(): string[]\n}\n\nexport const Models = ((name: string): Class<HasProps> => {\n  const model = overrides[name] || _all_models[name]\n\n  if (model == null) {\n    throw new Error(`Model '${name}' does not exist. This could be due to a widget\n                     or a custom model not being registered before first usage.`)\n  }\n\n  return model\n}) as Models\n\nModels.register = (name, model) => {\n  overrides[name] = model\n}\n\nModels.unregister = (name) => {\n  delete overrides[name]\n}\n\nModels.register_models = (models, force = false, errorFn?) => {\n  if (models == null)\n    return\n\n  for (const name in models) {\n    const model = models[name]\n\n    if (force || !_all_models.hasOwnProperty(name))\n      _all_models[name] = model\n    else if (errorFn != null)\n      errorFn(name)\n    else\n      console.warn(`Model '${name}' was already registered`)\n  }\n}\n\nexport const register_models = Models.register_models\n\nModels.registered_names = () => Object.keys(_all_models)\n\n// \"index\" is a map from the toplevel model IDs rendered by\n// embed.ts, to the view objects for those models. It doesn't\n// contain all views, only those explicitly rendered to an element\n// by embed.ts.\nexport const index: {[key: string]: View} = {}\n"]}