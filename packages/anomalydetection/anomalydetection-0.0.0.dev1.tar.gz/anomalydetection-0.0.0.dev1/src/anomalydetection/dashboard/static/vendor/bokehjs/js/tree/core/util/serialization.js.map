{"version":3,"sources":["core/util/serialization.ts"],"names":[],"mappings":"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","file":"serialization.js","sourcesContent":["import {Arrayable, TypedArray} from \"../types\"\nimport {isTypedArray, isArray, isObject} from \"./types\"\nimport {is_little_endian} from \"./compat\"\n\nexport const ARRAY_TYPES = {\n  uint8:   Uint8Array,\n  int8:    Int8Array,\n  uint16:  Uint16Array,\n  int16:   Int16Array,\n  uint32:  Uint32Array,\n  int32:   Int32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n}\n\nexport const DTYPES = {\n  Uint8Array:   \"uint8\"   as \"uint8\",\n  Int8Array:    \"int8\"    as \"int8\",\n  Uint16Array:  \"uint16\"  as \"uint16\",\n  Int16Array:   \"int16\"   as \"int16\",\n  Uint32Array:  \"uint32\"  as \"uint32\",\n  Int32Array:   \"int32\"   as \"int32\",\n  Float32Array: \"float32\" as \"float32\",\n  Float64Array: \"float64\" as \"float64\",\n}\n\nfunction arrayName(array: TypedArray): ArrayName {\n  if (\"name\" in array.constructor)\n    return array.constructor.name as ArrayName\n  else {\n    switch (true) {\n      case array instanceof Uint8Array:   return \"Uint8Array\"\n      case array instanceof Int8Array:    return \"Int8Array\"\n      case array instanceof Uint16Array:  return \"Uint16Array\"\n      case array instanceof Int16Array:   return \"Int16Array\"\n      case array instanceof Uint32Array:  return \"Uint32Array\"\n      case array instanceof Int32Array:   return \"Int32Array\"\n      case array instanceof Float32Array: return \"Float32Array\"\n      case array instanceof Float64Array: return \"Float64Array\"\n      default:\n        throw new Error(\"unsupported typed array\")\n    }\n  }\n}\n\nexport type ArrayName = keyof typeof DTYPES\n\nexport type DType = keyof typeof ARRAY_TYPES\n\nexport type ByteOrder = \"little\" | \"big\"\n\nexport const BYTE_ORDER: ByteOrder = is_little_endian ? \"little\" : \"big\"\n\nexport function swap16(a: Int16Array | Uint16Array): void {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2)\n  for (let i = 0, end = x.length; i < end; i += 2) {\n    const t = x[i]\n    x[i] = x[i + 1]\n    x[i + 1] = t\n  }\n}\n\nexport function swap32(a: Int32Array | Uint32Array | Float32Array): void {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4)\n  for (let i = 0, end = x.length; i < end; i += 4) {\n    let t = x[i]\n    x[i] = x[i + 3]\n    x[i + 3] = t\n    t = x[i + 1]\n    x[i + 1] = x[i + 2]\n    x[i + 2] = t\n  }\n}\n\nexport function swap64(a: Float64Array): void {\n  const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8)\n  for (let i = 0, end = x.length; i < end; i += 8) {\n    let t = x[i]\n    x[i] = x[i + 7]\n    x[i + 7] = t\n    t = x[i + 1]\n    x[i + 1] = x[i + 6]\n    x[i + 6] = t\n    t = x[i + 2]\n    x[i + 2] = x[i + 5]\n    x[i + 5] = t\n    t = x[i + 3]\n    x[i + 3] = x[i + 4]\n    x[i + 4] = t\n  }\n}\n\nexport type Shape = number[]\n\nexport interface BufferSpec {\n  __buffer__: string\n  order: ByteOrder\n  dtype: DType\n  shape: Shape\n}\n\nexport function process_buffer(spec: BufferSpec, buffers: [any, any][]): [TypedArray, Shape] {\n  const need_swap = spec.order !== BYTE_ORDER\n  const {shape} = spec\n  let bytes = null\n  for (const buf of buffers) {\n    const header = JSON.parse(buf[0])\n    if (header.id === spec.__buffer__) {\n      bytes = buf[1]\n      break\n    }\n  }\n  const arr = new (ARRAY_TYPES[spec.dtype])(bytes)\n  if (need_swap) {\n    if (arr.BYTES_PER_ELEMENT === 2) {\n      swap16(arr)\n    } else if (arr.BYTES_PER_ELEMENT === 4) {\n      swap32(arr)\n    } else if (arr.BYTES_PER_ELEMENT === 8) {\n      swap64(arr)\n    }\n  }\n  return [arr, shape]\n}\n\nexport function process_array(obj: NDArray | BufferSpec | Arrayable, buffers: [any, any][]): [Arrayable, number[]] {\n  if (isObject(obj) && '__ndarray__' in obj)\n    return decode_base64(obj)\n  else if (isObject(obj) && '__buffer__' in obj)\n    return process_buffer(obj, buffers)\n  else if (isArray(obj))\n    return [obj, []]\n  else\n    return undefined as never\n}\n\nexport function arrayBufferToBase64(buffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(buffer)\n  const chars = Array.from(bytes).map((b) => String.fromCharCode(b))\n  return btoa(chars.join(\"\"))\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binary_string = atob(base64)\n  const len = binary_string.length\n  const bytes = new Uint8Array(len)\n  for (let i = 0, end = len; i < end; i++) {\n    bytes[i] = binary_string.charCodeAt(i)\n  }\n  return bytes.buffer\n}\n\nexport interface NDArray {\n  __ndarray__: string\n  shape?: Shape\n  dtype: DType\n}\n\nexport function decode_base64(input: NDArray): [TypedArray, Shape] {\n  const bytes = base64ToArrayBuffer(input.__ndarray__)\n  const dtype = input.dtype\n  const shape = input.shape!\n\n  let array: TypedArray\n  if (dtype in ARRAY_TYPES)\n    array = new (ARRAY_TYPES[dtype])(bytes)\n  else\n    throw new Error(`unknown dtype: ${dtype}`)\n\n  return [array, shape]\n}\n\nexport function encode_base64(array: TypedArray, shape?: Shape): NDArray {\n  const b64 = arrayBufferToBase64(array.buffer)\n  const name = arrayName(array)\n\n  let dtype: DType\n  if (name in DTYPES)\n    dtype = DTYPES[name]\n  else\n    throw new Error(`unknown array type: ${name}`)\n\n  const data = {\n    __ndarray__: b64,\n    shape,\n    dtype,\n  }\n  return data\n}\n\nexport type Data = {[key: string]: Arrayable}\n\nexport type Shapes = {[key: string]: Shape | Shape[]}\n\nexport type EncodedData = {[key: string]: NDArray | Arrayable}\n\nexport function decode_column_data(data: EncodedData, buffers: [any, any][] = []): [Data, Shapes] {\n  const new_data: Data = {}\n  const new_shapes: Shapes = {}\n\n  for (const k in data) {\n\n    // might be array of scalars, or might be ragged array or arrays\n    const v = data[k]\n    if (isArray(v)) {\n\n      // v is just a regular array of scalars\n      if (v.length == 0 || !(isObject(v[0]) || isArray(v[0]))) {\n        new_data[k] = v\n        continue\n      }\n\n      // v is a ragged array of arrays\n      const arrays: Arrayable[] = []\n      const shapes: Shape[] = []\n      for (const obj of v) {\n        const [arr, shape] = process_array(obj as NDArray, buffers)\n        arrays.push(arr)\n        shapes.push(shape)\n      }\n\n      new_data[k] = arrays\n      new_shapes[k] = shapes\n\n    // must be object or array (single array case)\n    } else {\n      const [arr, shape] = process_array(v, buffers)\n      new_data[k] = arr\n      new_shapes[k] = shape\n    }\n  }\n\n  return [new_data, new_shapes]\n}\n\nexport function encode_column_data(data: Data, shapes?: Shapes): EncodedData {\n  const new_data: EncodedData = {}\n  for (const k in data) {\n    const v = data[k]\n    let new_v: NDArray | Arrayable\n    if (isTypedArray(v)) {\n      new_v = encode_base64(v, shapes != null ? shapes[k] as Shape : undefined)\n    } else if (isArray(v)) {\n      const new_array: any[] = []\n      for (let i = 0, end = v.length; i < end; i++) {\n        const item = v[i]\n        if (isTypedArray(item)) {\n          const shape = shapes != null && shapes[k] != null ? (shapes[k] as Shape[])[i] : undefined\n          new_array.push(encode_base64(item, shape))\n        } else\n          new_array.push(item)\n      }\n      new_v = new_array\n    } else\n      new_v = v\n    new_data[k] = new_v\n  }\n  return new_data\n}\n"]}