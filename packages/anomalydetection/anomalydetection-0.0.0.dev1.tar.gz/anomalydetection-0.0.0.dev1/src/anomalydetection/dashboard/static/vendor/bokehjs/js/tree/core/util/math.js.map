{"version":3,"sources":["core/util/math.ts"],"names":[],"mappings":";;AAAA,oBAA2B,KAAa;IACtC,OAAO,KAAK,GAAG,CAAC,EAAE;QAChB,KAAK,IAAI,CAAC,GAAC,IAAI,CAAC,EAAE,CAAA;KACnB;IACD,OAAO,KAAK,GAAG,CAAC,GAAC,IAAI,CAAC,EAAE,EAAE;QACxB,KAAK,IAAI,CAAC,GAAC,IAAI,CAAC,EAAE,CAAA;KACnB;IACD,OAAO,KAAK,CAAA;AACd,CAAC;AARD,gCAQC;AAED,oBAA2B,GAAW,EAAE,GAAW;IACjD,OAAO,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,GAAC,GAAG,CAAC,CAAC,CAAA;AACtC,CAAC;AAFD,gCAEC;AAED,uBAA8B,GAAW,EAAE,GAAW,EAAE,GAAW,EAAE,SAAgC;IACnG,IAAM,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,CAAA;IAChC,IAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;IAC9B,IAAM,IAAI,GAAG,UAAU,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,CAAA;IAC7E,IAAI,SAAS,IAAI,WAAW;QAC1B,OAAO,IAAI,CAAA;;QAEX,OAAO,CAAC,IAAI,CAAA;AAChB,CAAC;AARD,sCAQC;AAED;IACE,OAAO,IAAI,CAAC,MAAM,EAAE,CAAA;AACtB,CAAC;AAFD,wBAEC;AAED,kBAAyB,GAAW,EAAE,GAAY;IAChD,IAAI,GAAG,IAAI,IAAI,EAAE;QACf,GAAG,GAAG,GAAG,CAAA;QACT,GAAG,GAAG,CAAC,CAAA;KACR;IAED,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAA;AACxD,CAAC;AAPD,4BAOC;AAED,eAAsB,KAAuB,EAAE,GAAqB;IAClE;;;OAGG;IACH,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;AACzD,CAAC;AAND,sBAMC;AAGD,iFAAiF;AACjF,eAAsB,EAAU,EAAE,KAAa;IAC7C,6DAA6D;IAC7D,IAAI,EAAU,CAAA;IACd,IAAI,EAAU,CAAA;IACd,OAAO,IAAI,EAAE;QACX,EAAE,GAAG,MAAM,EAAE,CAAA;QACb,EAAE,GAAG,MAAM,EAAE,CAAA;QACb,EAAE,GAAG,CAAC,CAAC,GAAC,EAAE,GAAC,CAAC,CAAC,GAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,GAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;QACrC,IAAI,CAAC,CAAC,GAAC,EAAE,GAAC,EAAE,GAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,GAAC,EAAE;YAChC,MAAK;KACR;IACD,IAAI,EAAE,GAAG,EAAE,GAAC,EAAE,CAAA;IAEd,qFAAqF;IACrF,EAAE,GAAG,EAAE,GAAG,KAAK,GAAC,EAAE,CAAA;IAElB,OAAO,EAAE,CAAA;AACX,CAAC;AAjBD,sBAiBC;AAED,eAAsB,GAAW,EAAE,GAAW,EAAE,GAAW;IACzD,IAAI,GAAG,GAAG,GAAG;QACX,OAAO,GAAG,CAAA;IACZ,IAAI,GAAG,GAAG,GAAG;QACX,OAAO,GAAG,CAAA;IACZ,OAAO,GAAG,CAAA;AACZ,CAAC;AAND,sBAMC","file":"math.js","sourcesContent":["export function angle_norm(angle: number): number {\n  while (angle < 0) {\n    angle += 2*Math.PI\n  }\n  while (angle > 2*Math.PI) {\n    angle -= 2*Math.PI\n  }\n  return angle\n}\n\nexport function angle_dist(lhs: number, rhs: number): number {\n  return Math.abs(angle_norm(lhs-rhs))\n}\n\nexport function angle_between(mid: number, lhs: number, rhs: number, direction: \"anticlock\" | \"clock\"): boolean {\n  const norm_mid = angle_norm(mid)\n  const d = angle_dist(lhs, rhs)\n  const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d\n  if (direction == \"anticlock\")\n    return cond\n  else\n    return !cond\n}\n\nexport function random(): number {\n  return Math.random()\n}\n\nexport function randomIn(min: number, max?: number): number {\n  if (max == null) {\n    max = min\n    min = 0\n  }\n\n  return min + Math.floor(Math.random()*(max - min + 1))\n}\n\nexport function atan2(start: [number, number], end: [number, number]): number {\n  /*\n   * Calculate the angle between a line containing start and end points (composed\n   * of [x, y] arrays) and the positive x-axis.\n   */\n  return Math.atan2(end[1] - start[1], end[0] - start[0])\n}\n\n\n// http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\nexport function rnorm(mu: number, sigma: number): number {\n  // Generate a random normal with a mean of 0 and a sigma of 1\n  let r1: number\n  let r2: number\n  while (true) {\n    r1 = random()\n    r2 = random()\n    r2 = (2*r2-1)*Math.sqrt(2*(1/Math.E))\n    if (-4*r1*r1*Math.log(r1) >= r2*r2)\n      break\n  }\n  let rn = r2/r1\n\n  // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n  rn = mu + sigma*rn\n\n  return rn\n}\n\nexport function clamp(val: number, min: number, max: number): number {\n  if (val > max)\n    return max\n  if (val < min)\n    return min\n  return val\n}\n"]}