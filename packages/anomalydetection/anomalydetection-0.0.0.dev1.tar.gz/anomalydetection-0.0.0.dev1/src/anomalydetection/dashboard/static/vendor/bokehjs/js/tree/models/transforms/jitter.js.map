{"version":3,"sources":["models/transforms/jitter.ts"],"names":[],"mappings":";;;AAAA,yCAAqC;AAErC,uDAA0D;AAG1D,yCAAuD;AACvD,mCAAoC;AACpC,2CAA4C;AAe5C;IAA4B,kCAAS;IAInC,gBAAY,KAA6B;eACvC,kBAAM,KAAK,CAAC;IACd,CAAC;IAEM,gBAAS,GAAhB;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,QAAQ,CAAA;QAE9B,IAAI,CAAC,MAAM,CAAC;YACV,IAAI,EAAU,CAAE,CAAC,CAAC,MAAM,EAAQ,CAAC,CAAS;YAC1C,KAAK,EAAS,CAAE,CAAC,CAAC,MAAM,EAAQ,CAAC,CAAS;YAC1C,YAAY,EAAE,CAAE,CAAC,CAAC,YAAY,EAAE,SAAS,CAAC;YAC1C,KAAK,EAAS,CAAE,CAAC,CAAC,QAAQ,CAAgB;SAC3C,CAAC,CAAA;IACJ,CAAC;IAED,0BAAS,GAAT,UAAU,GAA+B;QACvC,IAAI,EAAqB,CAAA;QACzB,IAAI,IAAI,CAAC,KAAK,YAAY,0BAAW;YACnC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;aAC7B,IAAI,qBAAa,CAAC,GAAG,EAAE,gBAAQ,CAAC;YACnC,EAAE,GAAG,GAAG,CAAA;;YAER,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAA;QAE/B,IAAM,MAAM,GAAG,IAAI,YAAY,CAAC,EAAE,CAAC,MAAM,CAAC,CAAA;QAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAA;YACf,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;SAC7B;QACD,OAAO,MAAM,CAAA;IACf,CAAC;IAED,wBAAO,GAAP,UAAQ,CAAkB;QACxB,IAAI,IAAI,CAAC,KAAK,YAAY,0BAAW;YACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAA;aAC1C,IAAI,gBAAQ,CAAC,CAAC,CAAC;YAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;;YAEvB,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAA;IACjC,CAAC;IAES,yBAAQ,GAAlB,UAAmB,CAAS;QAC1B,QAAQ,IAAI,CAAC,YAAY,EAAE;YACzB,KAAK,SAAS;gBACZ,OAAO,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAC,IAAI,CAAC,KAAK,CAAA;YAC/D,KAAK,QAAQ;gBACX,OAAO,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;SACrD;IACH,CAAC;IACH,aAAC;AAAD,CArDA,AAqDC,CArD2B,qBAAS,GAqDpC;AArDY,wBAAM;AAsDnB,MAAM,CAAC,SAAS,EAAE,CAAA","file":"jitter.js","sourcesContent":["import {Transform} from \"./transform\"\nimport {Range} from \"../ranges/range\"\nimport {Factor, FactorRange} from \"../ranges/factor_range\"\nimport {Distribution} from \"core/enums\"\nimport {Arrayable} from \"core/types\"\nimport {isNumber, isArrayableOf} from \"core/util/types\"\nimport * as p from \"core/properties\"\nimport * as bokeh_math from \"core/util/math\"\n\nexport namespace Jitter {\n  export interface Attrs extends Transform.Attrs {\n    mean: number\n    width: number\n    distribution: Distribution\n    range: Range\n  }\n\n  export interface Props extends Transform.Props {}\n}\n\nexport interface Jitter extends Jitter.Attrs {}\n\nexport class Jitter extends Transform {\n\n  properties: Jitter.Props\n\n  constructor(attrs?: Partial<Jitter.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"Jitter\"\n\n    this.define({\n      mean:         [ p.Number      , 0        ],\n      width:        [ p.Number      , 1        ],\n      distribution: [ p.Distribution, 'uniform'],\n      range:        [ p.Instance               ],\n    })\n  }\n\n  v_compute(xs0: Arrayable<number | Factor>): Arrayable<number> {\n    let xs: Arrayable<number>\n    if (this.range instanceof FactorRange)\n      xs = this.range.v_synthetic(xs0)\n    else if (isArrayableOf(xs0, isNumber))\n      xs = xs0\n    else\n      throw new Error(\"unexpected\")\n\n    const result = new Float64Array(xs.length)\n    for (let i = 0; i < xs.length; i++) {\n      const x = xs[i]\n      result[i] = this._compute(x)\n    }\n    return result\n  }\n\n  compute(x: number | Factor): number {\n    if (this.range instanceof FactorRange)\n      return this._compute(this.range.synthetic(x))\n    else if (isNumber(x))\n      return this._compute(x)\n    else\n      throw new Error(\"unexpected\")\n  }\n\n  protected _compute(x: number): number {\n    switch (this.distribution) {\n      case \"uniform\":\n        return x + this.mean + (bokeh_math.random() - 0.5)*this.width\n      case \"normal\":\n        return x + bokeh_math.rnorm(this.mean, this.width)\n    }\n  }\n}\nJitter.initClass()\n"]}