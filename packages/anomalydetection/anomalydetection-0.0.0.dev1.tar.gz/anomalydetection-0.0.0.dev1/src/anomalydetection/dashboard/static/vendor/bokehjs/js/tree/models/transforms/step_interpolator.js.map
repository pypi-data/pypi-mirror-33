{"version":3,"sources":["models/transforms/step_interpolator.ts"],"names":[],"mappings":";;;AAAA,+CAA2C;AAE3C,mCAAoC;AACpC,yCAA6D;AAY7D;IAAsC,4CAAY;IAIhD,0BAAY,KAAuC;eACjD,kBAAM,KAAK,CAAC;IACd,CAAC;IAEM,0BAAS,GAAhB;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,kBAAkB,CAAA;QAExC,IAAI,CAAC,MAAM,CAAC;YACV,IAAI,EAAE,CAAE,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC;SAC7B,CAAC,CAAA;IACJ,CAAC;IAED,kCAAO,GAAP,UAAQ,CAAS;QACf,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QAEhB,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAC,CAAC,CAAC;gBACtE,OAAO,GAAG,CAAA;SACb;aAAM;YACL,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBACvB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;YAC1B,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAC,CAAC,CAAC;gBAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAC,CAAC,CAAC,CAAA;SACjD;QAED,IAAI,GAAW,CAAA;QACf,QAAQ,IAAI,CAAC,IAAI,EAAE;YACjB,KAAK,OAAO,CAAC,CAAC;gBACZ,GAAG,GAAG,qBAAa,CAAC,IAAI,CAAC,SAAS,EAAE,UAAA,GAAG,IAAI,OAAA,CAAC,IAAI,GAAG,EAAR,CAAQ,CAAC,CAAA;gBACpD,MAAK;aACN;YACD,KAAK,QAAQ,CAAC,CAAC;gBACb,GAAG,GAAG,iBAAS,CAAC,IAAI,CAAC,SAAS,EAAE,UAAA,GAAG,IAAI,OAAA,CAAC,IAAI,GAAG,EAAR,CAAQ,CAAC,CAAA;gBAChD,MAAK;aACN;YACD,KAAK,QAAQ,CAAC,CAAC;gBACb,IAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAC,EAAE,IAAK,OAAA,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA;gBAC1D,IAAM,OAAK,GAAG,WAAG,CAAC,KAAK,CAAC,CAAA;gBACxB,GAAG,GAAG,iBAAS,CAAC,KAAK,EAAE,UAAA,GAAG,IAAI,OAAA,OAAK,KAAK,GAAG,EAAb,CAAa,CAAC,CAAA;gBAC5C,MAAK;aACN;YACD;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAiB,IAAI,CAAC,IAAM,CAAC,CAAA;SAChD;QAED,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAA;IAC9C,CAAC;IACH,uBAAC;AAAD,CAnDA,AAmDC,CAnDqC,2BAAY,GAmDjD;AAnDY,4CAAgB;AAoD7B,gBAAgB,CAAC,SAAS,EAAE,CAAA","file":"step_interpolator.js","sourcesContent":["import {Interpolator} from \"./interpolator\"\nimport {StepMode} from \"core/enums\"\nimport * as p from \"core/properties\"\nimport {min, findIndex, findLastIndex} from \"core/util/array\"\n\nexport namespace StepInterpolator {\n  export interface Attrs extends Interpolator.Attrs {\n    mode: StepMode\n  }\n\n  export interface Props extends Interpolator.Props {}\n}\n\nexport interface StepInterpolator extends StepInterpolator.Attrs {}\n\nexport class StepInterpolator extends Interpolator {\n\n  properties: StepInterpolator.Props\n\n  constructor(attrs?: Partial<StepInterpolator.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"StepInterpolator\"\n\n    this.define({\n      mode: [ p.StepMode, \"after\"],\n    })\n  }\n\n  compute(x: number): number {\n    this.sort(false)\n\n    if (this.clip) {\n      if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length-1])\n        return NaN\n    } else {\n      if (x < this._x_sorted[0])\n        return this._y_sorted[0]\n      if (x > this._x_sorted[this._x_sorted.length-1])\n        return this._y_sorted[this._y_sorted.length-1]\n    }\n\n    let ind: number\n    switch (this.mode) {\n      case \"after\": {\n        ind = findLastIndex(this._x_sorted, num => x >= num)\n        break\n      }\n      case \"before\": {\n        ind = findIndex(this._x_sorted, num => x <= num)\n        break\n      }\n      case \"center\": {\n        const diffs = this._x_sorted.map((tx) => Math.abs(tx - x))\n        const mdiff = min(diffs)\n        ind = findIndex(diffs, num => mdiff === num)\n        break\n      }\n      default:\n        throw new Error(`unknown mode: ${this.mode}`)\n    }\n\n    return ind != -1 ? this._y_sorted[ind] : NaN\n  }\n}\nStepInterpolator.initClass()\n"]}