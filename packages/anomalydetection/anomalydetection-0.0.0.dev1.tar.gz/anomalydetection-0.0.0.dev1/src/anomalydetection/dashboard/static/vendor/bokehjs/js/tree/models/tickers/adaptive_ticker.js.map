{"version":3,"sources":["models/tickers/adaptive_ticker.ts"],"names":[],"mappings":"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","file":"adaptive_ticker.js","sourcesContent":["import {ContinuousTicker} from \"./continuous_ticker\"\nimport * as p from \"core/properties\"\nimport {argmin, nth} from \"core/util/array\"\n\n// Forces a number x into a specified range [min_val, max_val].\nfunction clamp(x: number, min_val: number, max_val: number): number {\n  return Math.max(min_val, Math.min(max_val, x))\n}\n\n// A log function with an optional base.\nfunction log(x: number, base=Math.E): number {\n  return Math.log(x) / Math.log(base)\n}\n\n// This Ticker produces nice round ticks at any magnitude.\n// AdaptiveTicker([1, 2, 5]) will choose the best tick interval from the\n// following:\n// ..., 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, ...\nexport namespace AdaptiveTicker {\n  export interface Attrs extends ContinuousTicker.Attrs {\n    base: number\n    mantissas: number[]\n    min_interval: number\n    max_interval: number\n  }\n\n  export interface Props extends ContinuousTicker.Props {}\n}\n\nexport interface AdaptiveTicker extends AdaptiveTicker.Attrs {}\n\nexport class AdaptiveTicker extends ContinuousTicker {\n\n  properties: AdaptiveTicker.Props\n\n  constructor(attrs?: Partial<AdaptiveTicker.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"AdaptiveTicker\"\n\n    this.define({\n      base:         [ p.Number, 10.0      ],\n      mantissas:    [ p.Array,  [1, 2, 5] ],\n      min_interval: [ p.Number, 0.0       ],\n      max_interval: [ p.Number            ],\n    })\n  }\n\n  /*protected*/ extended_mantissas: number[]\n  /*protected*/ base_factor: number\n\n  // These arguments control the range of possible intervals.  The interval I\n  // returned by get_interval() will be the one that most closely matches the\n  // desired number of ticks, subject to the following constraints:\n  // I = (M * B^N), where\n  // M is a member of mantissas,\n  // B is base,\n  // and N is an integer;\n  // and min_interval <= I <= max_interval.\n  initialize(): void {\n    super.initialize()\n\n    const prefix_mantissa = nth(this.mantissas, -1) / this.base\n    const suffix_mantissa = nth(this.mantissas,  0) * this.base\n    this.extended_mantissas = [prefix_mantissa, ...this.mantissas, suffix_mantissa]\n\n    this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval()\n  }\n\n  get_interval(data_low: number, data_high: number, desired_n_ticks: number): number {\n    const data_range = data_high - data_low\n    const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks)\n\n    const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base))\n    const ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor\n\n    // An untested optimization.\n    //   const ideal_mantissa = ideal_interval / ideal_magnitude\n    //   index = sortedIndex(this.extended_mantissas, ideal_mantissa)\n    //   candidate_mantissas = this.extended_mantissas[index..index + 1]\n    const candidate_mantissas = this.extended_mantissas\n\n    const errors = candidate_mantissas.map((mantissa) => {\n      return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)))\n    })\n    const best_mantissa = candidate_mantissas[argmin(errors)]\n    const interval = best_mantissa*ideal_magnitude\n\n    return clamp(interval, this.get_min_interval(), this.get_max_interval())\n  }\n}\n\nAdaptiveTicker.initClass()\n"]}