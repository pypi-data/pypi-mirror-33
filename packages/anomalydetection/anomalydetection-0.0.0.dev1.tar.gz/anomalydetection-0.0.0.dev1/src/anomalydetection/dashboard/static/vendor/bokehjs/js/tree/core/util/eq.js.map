{"version":3,"sources":["core/util/eq.ts"],"names":[],"mappings":"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","file":"eq.js","sourcesContent":["//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\nimport {isFunction} from \"./types\"\n\nconst toString = Object.prototype.toString\n\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a: any, b: any, aStack?: any[], bStack?: any[]): boolean {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) return a !== 0 || 1 / a === 1 / b\n  // A strict comparison is necessary because `null == undefined`.\n  if (a == null || b == null) return a === b\n  // Compare `[[Class]]` names.\n  const className = toString.call(a)\n  if (className !== toString.call(b)) return false\n  switch (className) {\n    // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n    case '[object RegExp]':\n    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n    case '[object String]':\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return '' + a === '' + b\n    case '[object Number]':\n      // `NaN`s are equivalent, but non-reflexive.\n      // Object(NaN) is equivalent to NaN\n      if (+a !== +a) return +b !== +b\n      // An `egal` comparison is performed for other numeric values.\n      return +a === 0 ? 1 / +a === 1 / b : +a === +b\n    case '[object Date]':\n    case '[object Boolean]':\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a === +b\n  }\n\n  const areArrays = className === '[object Array]'\n  if (!areArrays) {\n    if (typeof a != 'object' || typeof b != 'object') return false\n\n    // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n    // from different frames are.\n    const aCtor = a.constructor, bCtor = b.constructor\n    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\n                             isFunction(bCtor) && bCtor instanceof bCtor)\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false\n    }\n  }\n  // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n  // Initializing stack of traversed objects.\n  // It's done here since we only need them for objects and arrays comparison.\n  aStack = aStack || []\n  bStack = bStack || []\n  let length = aStack.length\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] === a) return bStack[length] === b\n  }\n\n  // Add the first object to the stack of traversed objects.\n  aStack.push(a)\n  bStack.push(b)\n\n  // Recursively compare objects and arrays.\n  if (areArrays) {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    length = a.length\n    if (length !== b.length) return false\n    // Deep compare the contents, ignoring non-numeric properties.\n    while (length--) {\n      if (!eq(a[length], b[length], aStack, bStack)) return false\n    }\n  } else {\n    // Deep compare objects.\n    const keys = Object.keys(a)\n    let key\n    length = keys.length\n    // Ensure that both objects contain the same number of properties before comparing deep equality.\n    if (Object.keys(b).length !== length) return false\n    while (length--) {\n      // Deep compare each member\n      key = keys[length]\n      if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack))) return false\n    }\n  }\n  // Remove the first object from the stack of traversed objects.\n  aStack.pop()\n  bStack.pop()\n  return true\n}\n\n// Perform a deep comparison to check if two objects are equal.\nexport function isEqual(a: any, b: any): boolean {\n  return eq(a, b)\n}\n"]}