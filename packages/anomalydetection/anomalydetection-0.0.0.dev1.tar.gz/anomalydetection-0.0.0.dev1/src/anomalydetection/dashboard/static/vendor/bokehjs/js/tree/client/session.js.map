{"version":3,"sources":["client/session.ts"],"names":[],"mappings":";;AAAA,wCAAmC;AACnC,qCAAwD;AACxD,4CAAwC;AAGxC;IAME,uBAA+B,WAA6B,EAAW,QAAa,CAAC,YAAY,EAAW,EAAU;QAAtH,iBAKC;QAL8B,gBAAW,GAAX,WAAW,CAAkB;QAAW,aAAQ,GAAR,QAAQ,CAAK;QAAwB,OAAE,GAAF,EAAE,CAAQ;QAJ5G,uBAAkB,GAAyB,UAAC,KAAK,IAAK,OAAA,KAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAA7B,CAA6B,CAAA;QAK3F,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;QAEhD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAA;QAChD,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,IAAI,CAAA;IACnC,CAAC;IAED,8BAAM,GAAN,UAAO,OAAgB;QACrB,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,EAAE,CAAA;QAEjC,IAAI,OAAO,KAAK,WAAW;YACzB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAA;aACxB,IAAI,OAAO,KAAK,IAAI;YACvB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;aACrB,IAAI,OAAO,KAAK,OAAO;YAC1B,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAA;;YAE3B,gBAAM,CAAC,KAAK,CAAC,gCAA8B,OAAO,CAAC,OAAO,EAAI,CAAC,CAAA;IACnE,CAAC;IAED,6BAAK,GAAL;QACE,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAA;IAC1B,CAAC;IAED,kCAAU,GAAV,UAAW,KAAU;QACnB,IAAM,OAAO,GAAG,iBAAO,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAA;QAClE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;IAChC,CAAC;IAED,aAAa,CAAC,0CAAkB,GAAlB;QACZ,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;IACzD,CAAC;IAED,6EAA6E;IAC7E,iFAAiF;IACjF,qBAAqB;IACrB,2CAAmB,GAAnB;QACE,IAAM,OAAO,GAAG,iBAAO,CAAC,MAAM,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAA;QACrD,IAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,OAAO,CAAC,CAAA;QACzD,OAAO,OAAO,CAAC,IAAI,CAAC,UAAC,KAAK,IAAK,OAAA,KAAK,CAAC,OAAO,EAAb,CAAa,CAAC,CAAA;IAC/C,CAAC;IAED,8EAA8E;IAC9E,4EAA4E;IAC5E,2EAA2E;IAC3E,4EAA4E;IAC5E,0EAA0E;IAC1E,4EAA4E;IAC5E,yEAAyE;IACzE,4EAA4E;IAC5E,yDAAyD;IACzD,uCAAe,GAAf;QACE,OAAO,IAAI,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,UAAC,CAAC,IAAK,OAAA,SAAS,EAAT,CAAS,CAAC,CAAA;IAC1D,CAAC;IAES,yCAAiB,GAA3B,UAA4B,KAAU;QACpC,oEAAoE;QACpE,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,CAAC,EAAE;YAC7B,OAAM;QAER,8DAA8D;QAC9D,IAAI,KAAK,YAAY,4BAAiB,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC9F,OAAM;QAER,8DAA8D;QAC9D,yEAAyE;QACzE,IAAM,OAAO,GAAG,iBAAO,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACzF,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;IAChC,CAAC;IAES,qCAAa,GAAvB,UAAwB,OAAgB;QACtC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE,CAAC,CAAA;IAC3E,CAAC;IAES,kCAAU,GAApB,UAAqB,OAAgB;QACnC,gBAAM,CAAC,KAAK,CAAC,2BAAyB,OAAO,CAAC,KAAK,EAAI,CAAC,CAAA;IAC1D,CAAC;IAES,qCAAa,GAAvB,UAAwB,OAAgB;QACtC,gBAAM,CAAC,KAAK,CAAC,8BAA4B,OAAO,CAAC,KAAK,EAAE,UAAK,OAAO,CAAC,OAAO,CAAC,MAAM,CAAG,CAAC,CAAA;IACzF,CAAC;IACH,oBAAC;AAAD,CAvFA,AAuFC,IAAA;AAvFY,sCAAa","file":"session.js","sourcesContent":["import {logger} from \"core/logging\"\nimport {EventManager, ModelChangedEvent} from \"document\"\nimport {Message} from \"protocol/message\"\nimport {ClientConnection} from \"./connection\"\n\nexport class ClientSession {\n\n  protected _document_listener: (event: any) => void = (event) => this._document_changed(event)\n\n  readonly event_manager: EventManager\n\n  constructor(protected readonly _connection: ClientConnection, readonly document: any /*Document*/, readonly id: string) {\n    this.document.on_change(this._document_listener)\n\n    this.event_manager = this.document.event_manager\n    this.event_manager.session = this\n  }\n\n  handle(message: Message): void {\n    const msgtype = message.msgtype()\n\n    if (msgtype === 'PATCH-DOC')\n      this._handle_patch(message)\n    else if (msgtype === 'OK')\n      this._handle_ok(message)\n    else if (msgtype === 'ERROR')\n      this._handle_error(message)\n    else\n      logger.debug(`Doing nothing with message ${message.msgtype()}`)\n  }\n\n  close(): void {\n    this._connection.close()\n  }\n\n  send_event(event: any): void {\n    const message = Message.create('EVENT', {}, JSON.stringify(event))\n    this._connection.send(message)\n  }\n\n  /*protected*/ _connection_closed(): void {\n    this.document.remove_on_change(this._document_listener)\n  }\n\n  // Sends a request to the server for info about the server, such as its Bokeh\n  // version. Returns a promise, the value of the promise is a free-form dictionary\n  // of server details.\n  request_server_info(): Promise<any> {\n    const message = Message.create('SERVER-INFO-REQ', {})\n    const promise = this._connection.send_with_reply(message)\n    return promise.then((reply) => reply.content)\n  }\n\n  // Sends some request to the server (no guarantee about which one) and returns\n  // a promise which is completed when the server replies. The purpose of this\n  // is that if you wait for the promise to be completed, you know the server\n  // has processed the request. This is useful when writing tests because once\n  // the server has processed this request it should also have processed any\n  // events or requests you sent previously, which means you can check for the\n  // results of that processing without a race condition. (This assumes the\n  // server processes events in sequence, which it mostly has to semantically,\n  // since reordering events might change the final state.)\n  force_roundtrip(): Promise<undefined> {\n    return this.request_server_info().then((_) => undefined)\n  }\n\n  protected _document_changed(event: any): void {\n    // Filter out events that were initiated by the ClientSession itself\n    if (event.setter_id === this.id)\n      return\n\n    // Filter out changes to attributes that aren't server-visible\n    if (event instanceof ModelChangedEvent && !(event.attr in event.model.serializable_attributes()))\n      return\n\n    // TODO (havocp) the connection may be closed here, which will\n    // cause this send to throw an error - need to deal with it more cleanly.\n    const message = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]))\n    this._connection.send(message)\n  }\n\n  protected _handle_patch(message: Message): void {\n    this.document.apply_json_patch(message.content, message.buffers, this.id)\n  }\n\n  protected _handle_ok(message: Message): void {\n    logger.trace(`Unhandled OK reply to ${message.reqid()}`)\n  }\n\n  protected _handle_error(message: Message): void {\n    logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content['text']}`)\n  }\n}\n"]}