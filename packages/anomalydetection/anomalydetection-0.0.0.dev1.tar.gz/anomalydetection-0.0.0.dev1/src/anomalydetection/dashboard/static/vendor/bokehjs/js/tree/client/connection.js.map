{"version":3,"sources":["client/connection.ts"],"names":[],"mappings":"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","file":"connection.js","sourcesContent":["import {Promise} from \"es6-promise\"\n\nimport {logger} from \"core/logging\"\nimport {Document} from \"document\"\nimport {Message} from \"protocol/message\"\nimport {Receiver} from \"protocol/receiver\"\nimport {ClientSession} from \"./session\"\n\nexport const DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\"\nexport const DEFAULT_SESSION_ID = \"default\"\n\nlet _connection_count: number = 0\n\nexport type Rejecter = (error: Error | string) => void\n\nexport class ClientConnection {\n\n  protected readonly _number = _connection_count++\n\n  socket: WebSocket | null = null\n  session: ClientSession | null = null\n\n  closed_permanently: boolean = false\n\n  protected _current_handler: ((message: Message) => void) | null = null\n  protected _pending_ack: [(connection: ClientConnection) => void, Rejecter] | null = null // null or [resolve,reject]\n  protected _pending_replies: {[key: string]: [(message: Message) => void, Rejecter]} = {} // map reqid to [resolve,reject]\n  protected readonly _receiver: Receiver = new Receiver()\n\n  constructor(readonly url: string = DEFAULT_SERVER_WEBSOCKET_URL,\n              readonly id: string = DEFAULT_SESSION_ID,\n              readonly args_string: string | null = null,\n              protected _on_have_session_hook: ((session: ClientSession) => void) | null = null,\n              protected _on_closed_permanently_hook: (() => void) | null = null) {\n\n    logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`)\n  }\n\n  connect(): Promise<ClientConnection> {\n    if (this.closed_permanently)\n      return Promise.reject(new Error(\"Cannot connect() a closed ClientConnection\"))\n    if (this.socket != null)\n      return Promise.reject(new Error(\"Already connected\"))\n\n    this._pending_replies = {}\n    this._current_handler = null\n\n    try {\n      let versioned_url = `${this.url}?bokeh-protocol-version=1.0&bokeh-session-id=${this.id}`\n      if (this.args_string != null && this.args_string.length > 0)\n        versioned_url += `&${this.args_string}`\n\n      this.socket = new WebSocket(versioned_url)\n\n      return new Promise((resolve, reject) => {\n        // \"arraybuffer\" gives us binary data we can look at;\n        // if we just needed an opaque blob we could use \"blob\"\n        this.socket!.binaryType = \"arraybuffer\"\n        this.socket!.onopen = () => this._on_open(resolve, reject)\n        this.socket!.onmessage = (event) => this._on_message(event)\n        this.socket!.onclose = (event) => this._on_close(event)\n        this.socket!.onerror = () => this._on_error(reject)\n      })\n    } catch (error) {\n      logger.error(`websocket creation failed to url: ${this.url}`)\n      logger.error(` - ${error}`)\n      return Promise.reject(error)\n    }\n  }\n\n  close(): void {\n    if (!this.closed_permanently) {\n      logger.debug(`Permanently closing websocket connection ${this._number}`)\n      this.closed_permanently = true\n      if (this.socket != null)\n        this.socket.close(1000, `close method called on ClientConnection ${this._number}`)\n      this.session!._connection_closed()\n      if (this._on_closed_permanently_hook != null) {\n        this._on_closed_permanently_hook()\n        this._on_closed_permanently_hook = null\n      }\n    }\n  }\n\n  protected _schedule_reconnect(milliseconds: number): void {\n    const retry = () => {\n      // TODO commented code below until we fix reconnection to repull\n      // the document when required. Otherwise, we get a lot of\n      // confusing errors that are causing trouble when debugging.\n      /*\n      if (this.closed_permanently) {\n      */\n        if (!this.closed_permanently)\n          logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`)\n        return\n      /*\n      } else {\n        logger.debug(`Attempting to reconnect websocket ${this._number}`)\n        this.connect()\n      }\n      */\n    }\n    setTimeout(retry, milliseconds)\n  }\n\n  send(message: Message): void {\n    if (this.socket == null)\n      throw new Error(`not connected so cannot send ${message}`)\n    message.send(this.socket)\n  }\n\n  send_with_reply(message: Message): Promise<Message> {\n    const promise = new Promise((resolve, reject) => {\n      this._pending_replies[message.msgid()] = [resolve, reject]\n      this.send(message)\n    })\n\n    return promise.then(\n      (message: Message) => {\n        if (message.msgtype() === \"ERROR\")\n          throw new Error(`Error reply ${message.content['text']}`)\n        else\n          return message\n      },\n      (error) => {\n        throw error\n      },\n    )\n  }\n\n  protected _pull_doc_json(): Promise<Message> {\n    const message = Message.create(\"PULL-DOC-REQ\", {})\n    const promise = this.send_with_reply(message)\n    return promise.then(\n      (reply) => {\n        if (!('doc' in reply.content))\n          throw new Error(\"No 'doc' field in PULL-DOC-REPLY\")\n        return reply.content['doc']\n      },\n      (error) => {\n        throw error\n      },\n    )\n  }\n\n  protected _repull_session_doc(): void {\n    if (this.session == null)\n      logger.debug(\"Pulling session for first time\")\n    else\n      logger.debug(\"Repulling session\")\n    this._pull_doc_json().then(\n      (doc_json) => {\n        if (this.session == null) {\n          if (this.closed_permanently)\n            logger.debug(\"Got new document after connection was already closed\")\n          else {\n            const document = (Document as any).from_json(doc_json)\n\n            // Constructing models changes some of their attributes, we deal with that\n            // here. This happens when models set attributes during construction\n            // or initialization.\n            const patch = (Document as any)._compute_patch_since_json(doc_json, document)\n            if (patch.events.length > 0) {\n              logger.debug(`Sending ${patch.events.length} changes from model construction back to server`)\n              const patch_message = Message.create('PATCH-DOC', {}, patch)\n              this.send(patch_message)\n            }\n\n            this.session = new ClientSession(this, document, this.id)\n\n            logger.debug(\"Created a new session from new pulled doc\")\n            if (this._on_have_session_hook != null) {\n              this._on_have_session_hook(this.session)\n              this._on_have_session_hook = null\n            }\n          }\n        } else {\n          this.session.document.replace_with_json(doc_json)\n          logger.debug(\"Updated existing session with new pulled doc\")\n        }\n      },\n      (error) => {\n        // handling the error here is useless because we wouldn't\n        // get errors from the resolve handler above, so see\n        // the catch below instead\n        throw error\n      },\n    ).catch((error) => {\n      if (console.trace != null)\n        console.trace(error)\n      logger.error(`Failed to repull session ${error}`)\n    })\n  }\n\n  protected _on_open(resolve: (connection: ClientConnection) => void, reject: Rejecter): void {\n    logger.info(`Websocket connection ${this._number} is now open`)\n    this._pending_ack = [resolve, reject]\n    this._current_handler = (message: Message) => {\n      this._awaiting_ack_handler(message)\n    }\n  }\n\n  protected _on_message(event: MessageEvent): void {\n    if (this._current_handler == null)\n      logger.error(\"Got a message with no current handler set\")\n\n    try {\n      this._receiver.consume(event.data)\n    } catch (e) {\n      this._close_bad_protocol(e.toString())\n    }\n\n    if (this._receiver.message == null)\n      return\n\n    const msg = this._receiver.message\n\n    const problem = msg.problem()\n    if (problem != null)\n      this._close_bad_protocol(problem)\n\n    this._current_handler!(msg)\n  }\n\n  protected _on_close(event: CloseEvent): void {\n    logger.info(`Lost websocket ${this._number} connection, ${event.code} (${event.reason})`)\n    this.socket = null\n\n    if (this._pending_ack != null) {\n      this._pending_ack[1](new Error(`Lost websocket connection, ${event.code} (${event.reason})`))\n      this._pending_ack = null\n    }\n\n    const pop_pending = () => {\n      for (const reqid in this._pending_replies) {\n        const promise_funcs = this._pending_replies[reqid]\n        delete this._pending_replies[reqid]\n        return promise_funcs\n      }\n      return null\n    }\n    let promise_funcs = pop_pending()\n    while (promise_funcs != null) {\n      promise_funcs[1](\"Disconnected\")\n      promise_funcs = pop_pending()\n    }\n    if (!this.closed_permanently)\n      this._schedule_reconnect(2000)\n  }\n\n  protected _on_error(reject: Rejecter): void {\n    logger.debug(`Websocket error on socket ${this._number}`)\n    reject(new Error(\"Could not open websocket\"))\n  }\n\n  protected _close_bad_protocol(detail: string): void {\n    logger.error(`Closing connection: ${detail}`)\n    if (this.socket != null)\n      this.socket.close(1002, detail) // 1002 = protocol error\n  }\n\n  protected _awaiting_ack_handler(message: Message): void {\n    if (message.msgtype() === \"ACK\") {\n      this._current_handler = (message: Message) => this._steady_state_handler(message)\n\n      // Reload any sessions\n      // TODO (havocp) there's a race where we might get a PATCH before\n      // we send and get a reply to our pulls.\n      this._repull_session_doc()\n\n      if (this._pending_ack != null) {\n        this._pending_ack[0](this)\n        this._pending_ack = null\n      }\n    } else\n      this._close_bad_protocol(\"First message was not an ACK\")\n  }\n\n  protected _steady_state_handler(message: Message): void {\n    if (message.reqid() in this._pending_replies) {\n      const promise_funcs = this._pending_replies[message.reqid()]\n      delete this._pending_replies[message.reqid()]\n      promise_funcs[0](message)\n    } else\n      this.session!.handle(message)\n  }\n}\n\n// Returns a promise of a ClientSession\n// The returned promise has a close() method in case you want to close before\n// getting a session; session.close() works too once you have a session.\nexport function pull_session(url: string, session_id: string, args_string?: string): Promise<ClientSession> {\n  let connection: ClientConnection\n\n  const promise = new Promise<ClientSession>((resolve, reject) => {\n    connection = new ClientConnection(url, session_id, args_string,\n      (session) => {\n        try {\n          resolve(session)\n        } catch (error) {\n          logger.error(`Promise handler threw an error, closing session ${error}`)\n          session.close()\n          throw error\n        }\n      },\n      () => {\n        // we rely on reject() as a no-op if we already resolved\n        reject(new Error(\"Connection was closed before we successfully pulled a session\"))\n      },\n    )\n    return connection.connect().then(\n      (_) => undefined,\n      (error) => {\n        logger.error(`Failed to connect to Bokeh server ${error}`)\n        throw error\n      },\n    )\n  })\n\n  /*\n  // add a \"close\" method to the promise... too weird?\n  promise.close = () => {\n    connection.close()\n  }\n  */\n  return promise\n}\n"]}