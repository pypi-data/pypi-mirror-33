{"version":3,"sources":["models/mappers/linear_color_mapper.ts"],"names":[],"mappings":";;;AAAA,qEAA+D;AAE/D,iDAA4C;AAU5C;IAAuC,6CAAqB;IAI1D,2BAAY,KAAwC;eAClD,kBAAM,KAAK,CAAC;IACd,CAAC;IAEM,2BAAS,GAAhB;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,mBAAmB,CAAA;IAC3C,CAAC;IAES,sCAAU,GAApB,UAAwB,IAAuB,EAAE,MAAoB,EACjE,OAAqB,EAAE,MAAqD;QACvE,IAAA,4BAAS,EAAE,4BAAS,EAAE,8BAAU,CAAU;QAEjD,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,eAAG,CAAC,IAAI,CAAC,CAAA;QACnD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,eAAG,CAAC,IAAI,CAAC,CAAA;QACtD,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAA;QAElC,IAAM,WAAW,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAA;QACpC,IAAM,eAAe,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,CAAA;QAE1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC/C,IAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;YAEjB,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;gBACZ,MAAM,CAAC,CAAC,CAAC,GAAG,SAAS,CAAA;gBACrB,SAAQ;aACT;YAED,wEAAwE;YACxE,wEAAwE;YACxE,UAAU;YACV,IAAI,CAAC,IAAI,IAAI,EAAE;gBACb,MAAM,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;gBAC5B,SAAQ;aACT;YAED,IAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,WAAW,CAAA;YACxC,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,eAAe,CAAC,CAAA;YAClD,IAAI,GAAG,GAAG,CAAC;gBACT,MAAM,CAAC,CAAC,CAAC,GAAG,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;iBACnD,IAAI,GAAG,GAAG,OAAO;gBACpB,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;;gBAE9D,MAAM,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAA;SAC3B;IACH,CAAC;IACH,wBAAC;AAAD,CAjDA,AAiDC,CAjDsC,+CAAqB,GAiD3D;AAjDY,8CAAiB;AAkD9B,iBAAiB,CAAC,SAAS,EAAE,CAAA","file":"linear_color_mapper.js","sourcesContent":["import {ContinuousColorMapper} from \"./continuous_color_mapper\"\nimport {Arrayable} from \"core/types\"\nimport {min, max} from \"core/util/arrayable\"\n\nexport namespace LinearColorMapper {\n  export interface Attrs extends ContinuousColorMapper.Attrs {}\n\n  export interface Props extends ContinuousColorMapper.Props {}\n}\n\nexport interface LinearColorMapper extends LinearColorMapper.Attrs {}\n\nexport class LinearColorMapper extends ContinuousColorMapper {\n\n  properties: LinearColorMapper.Props\n\n  constructor(attrs?: Partial<LinearColorMapper.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"LinearColorMapper\"\n  }\n\n  protected _v_compute<T>(data: Arrayable<number>, values: Arrayable<T>,\n      palette: Arrayable<T>, colors: {nan_color: T, low_color?: T, high_color?: T}): void {\n    const {nan_color, low_color, high_color} = colors\n\n    const low = this.low != null ? this.low : min(data)\n    const high = this.high != null ? this.high : max(data)\n    const max_key = palette.length - 1\n\n    const norm_factor = 1 / (high - low)\n    const normed_interval = 1 / palette.length\n\n    for (let i = 0, end = data.length; i < end; i++) {\n      const d = data[i]\n\n      if (isNaN(d)) {\n        values[i] = nan_color\n        continue\n      }\n\n      // This handles the edge case where d == high, since the code below maps\n      // values exactly equal to high to palette.length, which is greater than\n      // max_key\n      if (d == high) {\n        values[i] = palette[max_key]\n        continue\n      }\n\n      const normed_d = (d - low) * norm_factor\n      const key = Math.floor(normed_d / normed_interval)\n      if (key < 0)\n        values[i] = low_color != null ? low_color : palette[0]\n      else if (key > max_key)\n        values[i] = high_color != null ? high_color : palette[max_key]\n      else\n        values[i] = palette[key]\n    }\n  }\n}\nLinearColorMapper.initClass()\n"]}