{"version":3,"sources":["models/mappers/color_mapper.ts"],"names":[],"mappings":"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","file":"color_mapper.js","sourcesContent":["import {Transform} from \"../transforms/transform\"\nimport {Factor} from \"../ranges/factor_range\"\nimport * as p from \"core/properties\"\nimport {Arrayable, Color} from \"core/types\"\n\nimport {color2hex} from \"core/util/color\"\nimport {is_little_endian} from \"core/util/compat\"\n\nexport interface RGBAMapper {\n  v_compute(xs: Arrayable<number> | Arrayable<Factor>): Uint8Array\n}\n\nexport function _convert_color(color: string): number {\n  if (color[0] != \"#\")\n    color = color2hex(color)\n  if (color.length != 9)\n    color = color + 'ff'\n  return parseInt(color.slice(1), 16)\n}\n\nexport function _convert_palette(palette: Color[]): Uint32Array {\n  const new_palette = new Uint32Array(palette.length)\n  for (let i = 0, end = palette.length; i < end; i++)\n    new_palette[i] = _convert_color(palette[i])\n  return new_palette\n}\n\nexport function _uint32_to_rgba(values: Uint32Array): Uint8Array {\n  if (is_little_endian) {\n    const view = new DataView(values.buffer)\n    for (let i = 0, end = values.length; i < end; i++)\n      view.setUint32(i*4, values[i])\n  }\n\n  return new Uint8Array(values.buffer)\n}\n\nexport namespace ColorMapper {\n  export interface Attrs extends Transform.Attrs {\n    palette: Color[]\n    nan_color: Color\n  }\n\n  export interface Props extends Transform.Props {}\n}\n\nexport interface ColorMapper extends ColorMapper.Attrs {}\n\nexport abstract class ColorMapper extends Transform<Color> {\n\n  properties: ColorMapper.Props\n\n  constructor(attrs?: Partial<ColorMapper.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"ColorMapper\"\n\n    this.define({\n      palette:   [ p.Any           ], // TODO (bev)\n      nan_color: [ p.Color, \"gray\" ],\n    })\n  }\n\n  compute(_x: number): never {\n    // If it's just a single value, then a color mapper doesn't really make sense.\n    throw new Error(\"not supported\")\n  }\n\n  v_compute(xs: Arrayable<number> | Arrayable<Factor>): Arrayable<Color> {\n    const values: Color[] = new Array(xs.length)\n    this._v_compute(xs, values, this.palette, this._colors((c) => c))\n    return values\n  }\n\n  get rgba_mapper(): RGBAMapper {\n    const self = this\n    const palette = _convert_palette(this.palette)\n    const colors = this._colors(_convert_color)\n    return {\n      v_compute(xs: Arrayable<number> | Arrayable<Factor>): Uint8Array {\n        const values = new Uint32Array(xs.length)\n        self._v_compute(xs, values, palette, colors)\n        return _uint32_to_rgba(values)\n      },\n    }\n  }\n\n  protected _colors<T>(conv: (c: Color) => T): {nan_color: T} {\n    return {nan_color: conv(this.nan_color)}\n  }\n\n  protected abstract _v_compute<T>(xs: Arrayable<number> | Arrayable<Factor>, values: Arrayable<T>,\n                                   palette: Arrayable<T>, colors: {nan_color: T}): void\n}\nColorMapper.initClass()\n"]}