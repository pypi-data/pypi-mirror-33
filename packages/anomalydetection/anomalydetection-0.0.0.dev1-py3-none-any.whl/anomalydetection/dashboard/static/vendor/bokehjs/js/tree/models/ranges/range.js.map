{"version":3,"sources":["models/ranges/range.ts"],"names":[],"mappings":";;;AAAA,qCAAiC;AAGjC,mCAAoC;AACpC,yCAA0C;AAkB1C;IAAoC,iCAAK;IAIvC,eAAY,KAA4B;QAAxC,YACE,kBAAM,KAAK,CAAC,SACb;QAsBD,gCAA0B,GAAY,KAAK,CAAA;;IAtB3C,CAAC;IAEM,eAAS,GAAhB;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,OAAO,CAAA;QAE7B,IAAI,CAAC,MAAM,CAAC;YACV,QAAQ,EAAM,CAAE,CAAC,CAAC,GAAG,CAAE;YACvB,MAAM,EAAQ,CAAE,CAAC,CAAC,GAAG,CAAE;YACvB,YAAY,EAAE,CAAE,CAAC,CAAC,GAAG,CAAE;YACvB,YAAY,EAAE,CAAE,CAAC,CAAC,GAAG,CAAE;SACxB,CAAC,CAAA;QAEF,IAAI,CAAC,QAAQ,CAAC;YACZ,KAAK,EAAE,CAAE,CAAC,CAAC,KAAK,EAAE,EAAE,CAAE;SACvB,CAAC,CAAA;IACJ,CAAC;IASD,+BAAe,GAAf;QAAA,iBAGC;QAFC,iBAAM,eAAe,WAAE,CAAA;QACvB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,cAAM,OAAA,KAAI,CAAC,cAAc,EAAE,EAArB,CAAqB,CAAC,CAAA;IACxD,CAAC;IAED,qBAAK,GAAL;QACE;;;WAGG;QACH,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAA;IACpB,CAAC;IAES,8BAAc,GAAxB;QACE,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE;YACzB,IAAI,kBAAU,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAC3B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;;gBAEnB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;SAClC;IACH,CAAC;IACH,YAAC;AAAD,CAnDA,AAmDC,CAnDmC,aAAK,GAmDxC;AAnDqB,sBAAK;AAqD3B,KAAK,CAAC,SAAS,EAAE,CAAA","file":"range.js","sourcesContent":["import {Model} from \"../../model\"\nimport {Plot} from \"../plots/plot\"\nimport {CustomJS} from \"../callbacks/customjs\"\nimport * as p from \"core/properties\"\nimport {isFunction} from \"core/util/types\"\n\nexport namespace Range {\n  export interface Attrs extends Model.Attrs {\n    bounds: [number, number] | \"auto\" | null\n    min_interval: number\n    max_interval: number\n    callback?: ((obj: Range) => void) | CustomJS // XXX: Callback\n    plots: Plot[]\n  }\n\n  export interface Props extends Model.Props {\n    bounds: p.Property<[number, number] | \"auto\" | null>\n  }\n}\n\nexport interface Range extends Range.Attrs {}\n\nexport abstract class Range extends Model {\n\n  properties: Range.Props\n\n  constructor(attrs?: Partial<Range.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"Range\"\n\n    this.define({\n      callback:     [ p.Any ], // TODO: p.Either(p.Instance(Callback), p.Function)\n      bounds:       [ p.Any ], // TODO (bev)\n      min_interval: [ p.Any ],\n      max_interval: [ p.Any ],\n    })\n\n    this.internal({\n      plots: [ p.Array, [] ],\n    })\n  }\n\n  start: number\n  end: number\n  min: number\n  max: number\n\n  have_updated_interactively: boolean = false\n\n  connect_signals(): void {\n    super.connect_signals()\n    this.connect(this.change, () => this._emit_callback())\n  }\n\n  reset(): void {\n    /**\n     * This method should be reimplemented by subclasses and ensure that\n     * the callback, if exists, is executed at completion.\n     */\n    this.change.emit()\n  }\n\n  protected _emit_callback(): void {\n    if (this.callback != null) {\n      if (isFunction(this.callback))\n        this.callback(this)\n      else\n        this.callback.execute(this, {})\n    }\n  }\n}\n\nRange.initClass()\n"]}