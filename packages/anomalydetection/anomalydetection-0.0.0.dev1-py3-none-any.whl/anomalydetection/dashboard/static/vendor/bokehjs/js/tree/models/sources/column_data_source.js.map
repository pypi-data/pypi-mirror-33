{"version":3,"sources":["models/sources/column_data_source.ts"],"names":[],"mappings":"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","file":"column_data_source.js","sourcesContent":["import {ColumnarDataSource} from \"./columnar_data_source\"\nimport {HasProps} from \"core/has_props\"\nimport {Arrayable} from \"core/types\"\nimport * as p from \"core/properties\"\nimport {Set} from \"core/util/data_structures\"\nimport {Shape, encode_column_data, decode_column_data} from \"core/util/serialization\"\nimport {isTypedArray, isArray, isNumber, isObject} from \"core/util/types\"\nimport {TypedArray} from \"core/types\"\nimport * as typed_array from \"core/util/typed_array\"\nimport {keys} from \"core/util/object\"\n\n//exported for testing\nexport function stream_to_column(col: Arrayable, new_col: Arrayable, rollover?: number): Arrayable {\n  if (isArray(col)) {\n    const result = col.concat(new_col)\n\n    if (rollover != null && result.length > rollover)\n      return result.slice(-rollover)\n    else\n      return result\n  } else if (isTypedArray(col)) {\n    const total_len = col.length + new_col.length\n\n    // handle rollover case for typed arrays\n    if (rollover != null && total_len > rollover) {\n      const start = total_len - rollover\n      const end = col.length\n\n      // resize col if it is shorter than the rollover length\n      let result: TypedArray\n      if (col.length < rollover) {\n        result = new ((col as any).constructor)(rollover)\n        result.set(col, 0)\n      } else\n        result = col\n\n      // shift values in original col to accommodate new_col\n      for (let i = start, endi = end; i < endi; i++) {\n        result[i-start] = result[i]\n      }\n\n      // update end values in col with new_col\n      for (let i = 0, endi = new_col.length; i < endi; i++) {\n        result[i+(end-start)] = new_col[i]\n      }\n\n      return result\n    } else {\n      const tmp = new ((col as any).constructor)(new_col)\n      return typed_array.concat(col, tmp)\n    }\n  } else\n    throw new Error(\"unsupported array types\")\n}\n\n// exported for testing\nexport function slice(ind: number | {start?: number, stop?: number, step?: number}, length: number): [number, number, number] {\n  let start: number, step: number, stop: number\n\n  if (isNumber(ind)) {\n    start = ind\n    stop  = ind + 1\n    step  = 1\n  } else {\n    start = ind.start != null ? ind.start : 0\n    stop  = ind.stop  != null ? ind.stop  : length\n    step  = ind.step  != null ? ind.step  : 1\n  }\n\n  return [start, stop, step]\n}\n\nexport type Index = number | [number, number] | [number, number, number]\n\n// exported for testing\nexport function patch_to_column(col: Arrayable, patch: [Index, any][], shapes: Shape[]): Set<number> {\n  const patched: Set<number> = new Set()\n  let patched_range = false\n\n  for (let [ind, value] of patch) {\n\n    // make the single index case look like the length-3 multi-index case\n    let item: Arrayable, shape: Shape\n    if (isArray(ind)) {\n      const [i] = ind\n      patched.push(i)\n      shape = shapes[i]\n      item = col[i]\n    } else  {\n      if (isNumber(ind)) {\n        value = [value]\n        patched.push(ind)\n      } else\n        patched_range = true\n\n      ind = [0, 0, ind]\n      shape = [1, col.length]\n      item = col\n    }\n\n    // this is basically like NumPy's \"newaxis\", inserting an empty dimension\n    // makes length 2 and 3 multi-index cases uniform, so that the same code\n    // can handle both\n    if (ind.length === 2) {\n      shape = [1, shape[0]]\n      ind = [ind[0], 0, ind[1]]\n    }\n\n    // now this one nested loop handles all cases\n    let flat_index = 0\n    const [istart, istop, istep] = slice(ind[1], shape[0])\n    const [jstart, jstop, jstep] = slice(ind[2], shape[1])\n\n    for (let i = istart; i < istop; i += istep) {\n      for (let j = jstart; j < jstop; j += jstep) {\n        if (patched_range) {\n          patched.push(j)\n        }\n        item[(i*shape[1]) + j] = value[flat_index]\n        flat_index++\n      }\n    }\n  }\n\n  return patched\n}\n\n// Data source where the data is defined column-wise, i.e. each key in the\n// the data attribute is a column name, and its value is an array of scalars.\n// Each column should be the same length.\nexport namespace ColumnDataSource {\n  export interface Attrs extends ColumnarDataSource.Attrs {\n    data: {[key: string]: Arrayable}\n  }\n\n  export interface Props extends ColumnarDataSource.Props {\n    data: p.Property<{[key: string]: Arrayable}>\n  }\n}\n\nexport interface ColumnDataSource extends ColumnDataSource.Attrs {}\n\nexport class ColumnDataSource extends ColumnarDataSource {\n\n  properties: ColumnDataSource.Props\n\n  constructor(attrs?: Partial<ColumnDataSource.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = 'ColumnDataSource'\n\n    this.define({\n      data: [ p.Any, {} ],\n    })\n  }\n\n  initialize(): void {\n    super.initialize();\n    [this.data, this._shapes] = decode_column_data(this.data)\n  }\n\n  attributes_as_json(include_defaults: boolean = true, value_to_json = ColumnDataSource._value_to_json): any {\n    const attrs: {[key: string]: any} = {}\n    const obj = this.serializable_attributes()\n    for (const key of keys(obj)) {\n      let value = obj[key]\n      if (key === 'data')\n        value = encode_column_data(value, this._shapes)\n\n      if (include_defaults)\n        attrs[key] = value\n      else if (key in this._set_after_defaults)\n        attrs[key] = value\n    }\n    return value_to_json(\"attributes\", attrs, this)\n  }\n\n  static _value_to_json(key: string, value: any, optional_parent_object: any): any {\n    if (isObject(value) && key === 'data')\n      return encode_column_data(value, optional_parent_object._shapes)\n    else\n      return HasProps._value_to_json(key, value, optional_parent_object)\n  }\n\n  stream(new_data: {[key: string]: any[]}, rollover?: number): void {\n    const {data} = this\n    for (const k in new_data) {\n      data[k] = stream_to_column(data[k], new_data[k], rollover)\n    }\n    this.setv({data}, {silent: true})\n    this.streaming.emit()\n  }\n\n  patch(patches: [Index, any][]): void {\n    const {data} = this\n    let patched: Set<number> = new Set()\n    for (const k in patches) {\n      const patch = patches[k]\n      patched = patched.union(patch_to_column(data[k], patch, this._shapes[k] as Shape[]))\n    }\n    this.setv({data}, {silent: true})\n    this.patching.emit(patched.values)\n  }\n}\nColumnDataSource.initClass()\n"]}