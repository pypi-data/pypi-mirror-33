{"version":3,"sources":["core/util/data_structures.ts"],"names":[],"mappings":"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","file":"data_structures.js","sourcesContent":["import {difference, copy} from \"./array\"\nimport {isEqual} from \"./eq\"\nimport {isArray} from \"./types\"\n\nexport class MultiDict<T> {\n\n  _dict: {[key: string]: T | T[]} = {}\n\n  _existing(key: string): T | T[] | null {\n    if (key in this._dict)\n      return this._dict[key]\n    else\n      return null\n  }\n\n  add_value(key: string, value: T): void {\n    /*\n    if value == null\n      throw new Error(\"Can't put null in this dict\")\n    if isArray(value)\n      throw new Error(\"Can't put arrays in this dict\")\n    */\n    const existing = this._existing(key)\n    if (existing == null) {\n      this._dict[key] = value\n    } else if (isArray(existing)) {\n      existing.push(value)\n    } else {\n      this._dict[key] = [existing, value]\n    }\n  }\n\n  remove_value(key: string, value: T): void {\n    const existing = this._existing(key)\n    if (isArray(existing)) {\n      const new_array = difference(existing, [value])\n      if (new_array.length > 0)\n        this._dict[key] = new_array\n      else\n        delete this._dict[key]\n    } else if (isEqual(existing, value)) {\n      delete this._dict[key]\n    }\n  }\n\n  get_one(key: string, duplicate_error: string): T | null {\n    const existing = this._existing(key)\n    if (isArray(existing)) {\n      if (existing.length === 1)\n        return existing[0]\n      else\n        throw new Error(duplicate_error)\n    } else\n      return existing\n  }\n}\n\nexport class Set<T> {\n\n  values: T[]\n\n  constructor(obj?: T[] | Set<T>) {\n    if (obj == null) {\n      this.values = []\n    } else if (obj instanceof Set) {\n      this.values = copy(obj.values)\n    } else {\n      this.values = this._compact(obj)\n    }\n  }\n\n  protected _compact(array: T[]): T[] {\n    const newArray: T[] = []\n\n    for (const item of array) {\n      if (newArray.indexOf(item) === -1) {\n        newArray.push(item)\n      }\n    }\n\n    return newArray\n  }\n\n  push(item: T): void {\n    if (this.missing(item))\n      this.values.push(item)\n  }\n\n  remove(item: T): void {\n    const i = this.values.indexOf(item)\n    this.values = this.values.slice(0, i).concat(this.values.slice(i + 1))\n  }\n\n  length(): number {\n    return this.values.length\n  }\n\n  includes(item: T): boolean {\n    return this.values.indexOf(item) != -1\n  }\n\n  missing(item: T): boolean {\n    return !this.includes(item)\n  }\n\n  slice(from: number, to: number): T[] {\n    return this.values.slice(from, to)\n  }\n\n  join(str: string): string {\n    return this.values.join(str)\n  }\n\n  toString(): string {\n    return this.join(', ')\n  }\n\n  union(set: T[] | Set<T>): Set<T> {\n    set = new Set<T>(set)\n    return new Set(this.values.concat(set.values))\n  }\n\n  intersect(set: T[] | Set<T>): Set<T> {\n    set = new Set<T>(set)\n    const newSet = new Set<T>()\n\n    for (const item of set.values) {\n      if (this.includes(item) && set.includes(item))\n        newSet.push(item)\n    }\n\n    return newSet\n  }\n\n  diff(set: T[] | Set<T>): Set<T> {\n    set = new Set<T>(set)\n    const newSet = new Set<T>()\n\n    for (const item of this.values) {\n      if (set.missing(item))\n        newSet.push(item)\n    }\n\n    return newSet\n  }\n}\n"]}