{"version":3,"sources":["models/tickers/continuous_ticker.ts"],"names":[],"mappings":"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","file":"continuous_ticker.js","sourcesContent":["import {Ticker, TickSpec} from \"./ticker\"\nimport * as p from \"core/properties\"\nimport {range} from \"core/util/array\"\nimport {isStrictNaN} from \"core/util/types\"\n\n// The base class for all Ticker objects.  It needs to be subclassed before\n// being used.  The simplest subclass is SingleIntervalTicker.\n//\n// The main value of a Ticker is its get_ticks() method, which takes a min and\n// max value and (optionally) a desired number of ticks, and returns an array\n// of approximately that many ticks, evenly spaced, with nice round values,\n// within that range.\n//\n// Different Tickers are suited to different types of data or different\n// magnitudes.  To make it possible to select Tickers programmatically, they\n// also support some additional methods: get_interval(), get_min_interval(),\n// and get_max_interval().\n\nexport namespace ContinuousTicker {\n  export interface Attrs extends Ticker.Attrs {\n    num_minor_ticks: number\n    desired_num_ticks: number\n  }\n\n  export interface Props extends Ticker.Props {}\n}\n\nexport interface ContinuousTicker extends ContinuousTicker.Attrs {}\n\nexport abstract class ContinuousTicker extends Ticker<number> {\n\n  properties: ContinuousTicker.Props\n\n  constructor(attrs?: Partial<ContinuousTicker.Attrs>) {\n    super(attrs)\n  }\n\n  static initClass(): void {\n    this.prototype.type = \"ContinuousTicker\"\n\n    this.define({\n      num_minor_ticks:   [ p.Number, 5 ],\n      desired_num_ticks: [ p.Number, 6 ],\n    })\n  }\n\n  min_interval: number\n  max_interval: number\n\n  get_ticks(data_low: number, data_high: number, _range: any, cross_loc: any, _: any): TickSpec<number> {\n    return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks)\n  }\n\n  // Given min and max values and a number of ticks, returns a tick interval\n  // that produces approximately the right number of nice ticks.  (If you just\n  // implement this method, get_ticks_no_defaults() will work.  However, if\n  // you want to return ticks that aren't evenly spaced, you'll need to\n  // override get_ticks_no_defaults() directly.  In that case, you should\n  // still implement get_interval(), because users can call it to get a sense\n  // of what the spacing will be for a given range.)\n  // FIXME Is that necessary?  Maybe users should just call get_ticks() and\n  // figure it out from that.\n  abstract get_interval(data_low: number, data_high: number, desired_n_ticks: number): number\n\n  // The version of get_ticks() that does the work (and the version that\n  // should be overridden in subclasses).\n  get_ticks_no_defaults(data_low: number, data_high: number, _cross_loc: any, desired_n_ticks: number): TickSpec<number> {\n    const interval = this.get_interval(data_low, data_high, desired_n_ticks)\n    const start_factor = Math.floor(data_low / interval)\n    const end_factor   = Math.ceil(data_high / interval)\n    let factors: number[]\n    if (isStrictNaN(start_factor) || isStrictNaN(end_factor))\n      factors = []\n    else\n      factors = range(start_factor, end_factor + 1)\n    const ticks =\n      factors.map((factor) => factor*interval)\n             .filter((tick) => data_low <= tick && tick <= data_high)\n    const num_minor_ticks = this.num_minor_ticks\n    const minor_ticks = []\n    if (num_minor_ticks > 0 && ticks.length > 0) {\n      const minor_interval = interval / num_minor_ticks\n      const minor_offsets = range(0, num_minor_ticks).map((i) => i*minor_interval)\n      for (const x of minor_offsets.slice(1)) {\n        const mt = ticks[0] - x\n        if (data_low <= mt && mt <= data_high) {\n          minor_ticks.push(mt)\n        }\n      }\n      for (const tick of ticks) {\n        for (const x of minor_offsets) {\n          const mt = tick + x\n          if (data_low <= mt && mt <= data_high) {\n            minor_ticks.push(mt)\n          }\n        }\n      }\n    }\n    return {\n      major: ticks,\n      minor: minor_ticks,\n    }\n  }\n\n  // Returns the smallest interval that can be returned by get_interval().\n  get_min_interval(): number {\n    return this.min_interval\n  }\n\n  // Returns the largest interval that can be returned by get_interval().\n  get_max_interval(): number {\n    return this.max_interval != null ? this.max_interval : Infinity\n  }\n\n  // Returns the interval size that would produce exactly the number of\n  // desired ticks.  (In general we won't use exactly this interval, because\n  // we want the ticks to be round numbers.)\n  get_ideal_interval(data_low: number, data_high: number, desired_n_ticks: number): number {\n    const data_range = data_high - data_low\n    return data_range / desired_n_ticks\n  }\n}\n\nContinuousTicker.initClass()\n"]}