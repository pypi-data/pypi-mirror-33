"""
Calculations provided by plugin

Register calculations via the "aiida.calculations" entry point in setup.json.
"""

from aiida.orm.calculation.job import JobCalculation
from aiida.common.utils import classproperty
from aiida.common.exceptions import (InputValidationError, ValidationError)
from aiida.common.datastructures import (CalcInfo, CodeInfo)
from aiida.orm import DataFactory

ParameterData = DataFactory('parameter')
SinglefileData = DataFactory('singlefile')


class DistanceMatrixCalculation(JobCalculation):
    """
    AiiDA calculation plugin for simple "multiplication"
    
    Simple AiiDA plugin for wrapping a code that adds two numbers.
    """

    _OUTPUT_FILE_NAME = 'distance.matrix'

    def _init_internal_params(self):
        """
        Init internal parameters at class load time
        """
        # reuse base class function
        super(DistanceMatrixCalculation, self)._init_internal_params()

        self._default_parser = 'phtools.dmatrix'

    @classproperty
    def _use_methods(cls):
        """
        Add use_* methods for calculations.
        
        Code below enables the usage
        my_calculation.use_parameters(my_parameters)
        """
        use_dict = JobCalculation._use_methods
        use_dict.update({
            "surface_sample": {
                'valid_types': SinglefileData,
                'additional_parameter': None,
                'linkname': 'surface_sample',
                'docstring': "surface sample generated by zeo++",
            },
            "cell": {
                'valid_types': SinglefileData,
                'additional_parameter': None,
                'linkname': 'cell',
                'docstring': "cell file containing cell vectors",
            },
        })
        return use_dict

    def _validate_inputs(self, inputdict):
        """ Validate input links.
        """
        # Check code
        try:
            code = inputdict.pop(self.get_linkname('code'))
        except KeyError:
            raise InputValidationError("No code specified for this "
                                       "calculation")

        # Check input files
        try:
            surface_sample = inputdict.pop(self.get_linkname('surface_sample'))
            if not isinstance(surface_sample, SinglefileData):
                raise InputValidationError(
                    "surface_sample not of type SinglefileData")
        except KeyError:
            raise InputValidationError(
                "No input structure specified for calculation")

        try:
            cell = inputdict.pop(self.get_linkname('cell'))
            if not isinstance(cell, SinglefileData):
                raise InputValidationError("cell not of type SinglefileData")
        except KeyError:
            raise InputValidationError(
                "No input structure specified for calculation")

        # Check that nothing is left unparsed
        if inputdict:
            raise ValidationError("Unrecognized inputs: {}".format(inputdict))

        return code, surface_sample, cell

    def _prepare_for_submission(self, tempfolder, inputdict):
        """
        Create input files.

            :param tempfolder: aiida.common.folders.Folder subclass where
                the plugin should put all its files.
            :param inputdict: dictionary of the input nodes as they would
                be returned by get_inputs_dict
        """
        code, surface_sample, cell = \
                self._validate_inputs(inputdict)

        # Prepare CalcInfo to be returned to aiida
        calcinfo = CalcInfo()
        calcinfo.uuid = self.uuid
        calcinfo.local_copy_list = [
            [surface_sample.get_file_abs_path(), surface_sample.filename],
            [cell.get_file_abs_path(), cell.filename],
        ]
        calcinfo.remote_copy_list = []
        calcinfo.retrieve_list = self.output_files()

        codeinfo = CodeInfo()
        # will call ./code.py in.json out.json
        codeinfo.cmdline_params = self.cmdline_params(
            surface_sample_file_name=surface_sample.filename,
            cell_file_name=cell.filename,
        )
        codeinfo.code_uuid = code.uuid
        calcinfo.codes_info = [codeinfo]

        return calcinfo

    def cmdline_params(self, surface_sample_file_name, cell_file_name):
        """Synthesize command line parameters

        e.g. [ ['struct.vsa'], ['struct.cell']]
        """
        parameters = []

        parameters += [surface_sample_file_name]
        parameters += [cell_file_name]
        parameters += [self._OUTPUT_FILE_NAME]

        return map(str, parameters)

    def output_files(self):
        return [self._OUTPUT_FILE_NAME]
