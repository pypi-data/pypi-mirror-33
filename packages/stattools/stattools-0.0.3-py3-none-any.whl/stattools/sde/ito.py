"""Simulate sample paths of Itô diffusions."""

import numpy as np


class ItoDiffusion(object):
    def __init__(self, drift, diffusion):
        """Initialize the coefficients of the Itô diffusion.

        Parameters
        ----------
        drift : callable
            The drift coefficient (a numeric function of time).
        diffusion : callable
            The diffusion coefficient (a numeric function of time).
        """
        self.drift = drift
        self.diffusion = diffusion

    def simulate(self, T, N, x0, seed=None):
        """Simulate one sample path of the Itô diffusion.

        The time interval [0, T] is partitioned into the N+1 points
        0 < T/N < 2T/N < ... < (N-1)T/N < T. The solution X of the SDE on the
        interval [0, T] is approximated recursively by
        X(0) = x0,
        X((n+1)Δt) = X(nΔt) + b(X(nΔt)) Δt + σ(X(nΔt)) ΔB(n) (for 0 ≤ n < N),
        where Δt = T/N (the time step) and ΔB(n) = B((n+1)Δt) - B(nΔt) (the
        Brownian increment). Note that ΔB(n) ~ N(0, Δt) and ΔB(1), ..., ΔB(N)
        are independent.

        Parameters
        ----------
        T : positive float
            The final time.
        N : int
            Number of sub-intervals in the partition of [0, T].
        x0 : float
            The starting point of the diffusion at time 0.
        seed : int
            Seed for a numpy.random.RandomState object.

        Returns
        -------
        x : numpy.ndarray
            Approximate solution of the SDE at the discrete times.
        t : numpy.ndarray
            The discretized time interval.
        """
        # Define the time step and the discretized time interval
        dt = float(T) / N
        t = np.linspace(start=0, stop=T, num=(N + 1))

        # Generate the Brownian motion increments
        rs = np.random.RandomState(seed)
        bm_increments = rs.normal(loc=0, scale=np.sqrt(dt), size=N)

        # Function to return the next value of the Euler-Maruyama method
        def euler_maruyama(prev, inc):
            # prev: previous value generated by the Euler-Maruyama method.
            # inc: the current Brownian motion increment.
            return prev + self.drift(prev) * dt + self.diffusion(prev) * inc

        # Generate the approximate solution to the SDE using Euler-Maruyama
        x = np.empty(N + 1)
        x[0] = x0
        for i, inc in enumerate(bm_increments):
            x[i + 1] = x[i] + self.drift(x[i]) * dt + self.diffusion(x[i]) * inc

        return x, t


class BrownianMotion(ItoDiffusion):
    """Simulate Brownian motion (with drift).
    Brownian motion with drift is a stochastic process X satisfying the SDE
    dX(t) = μ dt + σ dB(t), where μ and σ are constants and B is standard
    Brownian motion.
    Explicitly, X(t) = X(0) + μt + σB(t). In particular, if μ = 0 and σ = 1,
    then X is Brownian motion started at X(0).
    """

    def __init__(self, mu=0.0, sigma=1.0):
        """Initialize a Brownian motion with drift.
        If no parameters are specified, initialize a standard Brownian motion.

        Parameters
        ----------
        mu : float
            The constant drift rate.
        sigma : float
            The constant standard deviation scaling.
        """
        super(BrownianMotion, self).__init__(lambda _: mu, lambda _: sigma)


class GeometricBrownianMotion(ItoDiffusion):
    """Simulate geometric Brownian motion.
    Geometric Brownian motion is a stochastic process X satisfying the SDE
    dX(t) = μX(t) dt + σX(t) dB(t), where μ and σ are constants and B is
    standard Brownian motion. This process comes up in, e.g., the Black-Scholes
    model of financial markets as the stock price process.
    Explicitly, X(t) = X(0)exp((μ - (1/2)σ^2)t + σB(t)).
    """

    def __init__(self, mu, sigma):
        """Initialize a geometric Brownian motion.

        Parameters
        ----------
        mu : float
            The constant drift rate.
        sigma : float
            The constant volatility.
        """
        super(GeometricBrownianMotion, self).__init__(lambda x: mu * x,
                                                      lambda x: sigma * x)


class OrnsteinUhlenbeck(ItoDiffusion):
    """Simulate an Ornstein-Uhlenbeck process.
    An Ornstein-Uhlenbeck process is a stochastic process X satisfying the SDE
    dX(t) = θ(μ - X(t)) dt + σ dB(t), where θ, μ, and σ are constants and B is
    standard Brownian motion.
    """

    def __init__(self, theta, mu, sigma):
        """Initialize an Ornstein-Uhlenbeck process.

        Parameters
        ----------
        theta : float
            The constant decay rate.
        mu : float
            The asymptotic mean (equilibrium).
        sigma : float
            The constant standard deviation scaling.
        """
        super(OrnsteinUhlenbeck, self).__init__(lambda x: theta * (mu - x),
                                                lambda _: sigma)
