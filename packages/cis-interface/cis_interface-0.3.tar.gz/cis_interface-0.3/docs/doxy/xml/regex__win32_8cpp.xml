<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="regex__win32_8cpp" kind="file" language="C++">
    <compoundname>regex_win32.cpp</compoundname>
    <includes local="no">string</includes>
    <includes local="no">regex</includes>
    <includes local="no">cstdint</includes>
    <includes refid="regex__win32_8h" local="yes">regex_win32.h</includes>
    <incdepgraph>
      <node id="2740">
        <label>/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp</label>
        <link refid="regex__win32_8cpp"/>
        <childnode refid="2741" relation="include">
        </childnode>
        <childnode refid="2742" relation="include">
        </childnode>
        <childnode refid="2743" relation="include">
        </childnode>
        <childnode refid="2744" relation="include">
        </childnode>
      </node>
      <node id="2743">
        <label>cstdint</label>
      </node>
      <node id="2741">
        <label>string</label>
      </node>
      <node id="2742">
        <label>regex</label>
      </node>
      <node id="2744">
        <label>regex_win32.h</label>
        <link refid="regex__win32_8h_source"/>
      </node>
    </incdepgraph>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="regex__win32_8cpp_1a622664eb5ce924f112e7a848dab5592c" prot="public" static="no">
        <type>std::regex_iterator&lt; const char * &gt;</type>
        <definition>typedef std::regex_iterator&lt;const char *&gt; Myiter</definition>
        <argsstring></argsstring>
        <name>Myiter</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="7" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="7" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="regex__win32_8cpp_1a6161339521696fe0d5ca1efb737d5f59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int count_matches</definition>
        <argsstring>(const char *regex_text, const char *to_match)</argsstring>
        <name>count_matches</name>
        <param>
          <type>const char *</type>
          <declname>regex_text</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>to_match</declname>
        </param>
        <briefdescription>
<para>Count the number of times a regular expression is matched in a string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">regex_text</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be compiled into a regex. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to_match</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be checked for matches. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int Number of matches found. -1 is returned if the regex could not be compiled. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="19" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="19" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="regex__win32_8cpp_1aa582d9ee799ff04a47c5bc2f921c4e20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int find_matches</definition>
        <argsstring>(const char *regex_text, const char *to_match, size_t **sind, size_t **eind)</argsstring>
        <name>find_matches</name>
        <param>
          <type>const char *</type>
          <declname>regex_text</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>to_match</declname>
        </param>
        <param>
          <type>size_t **</type>
          <declname>sind</declname>
        </param>
        <param>
          <type>size_t **</type>
          <declname>eind</declname>
        </param>
        <briefdescription>
<para>Find first match to regex and any sub-matches. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">regex_text</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be compiled into a regex. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to_match</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be checked for matches. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sind</parametername>
</parameternamelist>
<parameterdescription>
<para>size_t ** indices of where matches begin. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">eind</parametername>
</parameternamelist>
<parameterdescription>
<para>size_t ** indices of where matches ends. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int Number of matches/submatches found. -1 is returned if the regex could not be compiled. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="45" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="45" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="regex__win32_8cpp_1a4adb146f89606bcd91a1b70ed8abf888" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int find_match</definition>
        <argsstring>(const char *regex_text, const char *to_match, size_t *sind, size_t *eind)</argsstring>
        <name>find_match</name>
        <param>
          <type>const char *</type>
          <declname>regex_text</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>to_match</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>sind</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>eind</declname>
        </param>
        <briefdescription>
<para>Find first match to regex. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">regex_text</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be compiled into a regex. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to_match</parametername>
</parameternamelist>
<parameterdescription>
<para>constant character pointer to string that should be checked for matches. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sind</parametername>
</parameternamelist>
<parameterdescription>
<para>size_t index where match begins. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">eind</parametername>
</parameternamelist>
<parameterdescription>
<para>size_t index where match ends. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int Number of matches found. -1 is returned if the regex could not be compiled. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="79" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="79" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="regex__win32_8cpp_1a31a4f6d3f7382e48201fc52e682df3f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int regex_replace_nosub</definition>
        <argsstring>(char *buf, const size_t len_buf, const char *re, const char *rp, const size_t nreplace)</argsstring>
        <name>regex_replace_nosub</name>
        <param>
          <type>char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>len_buf</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>re</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>rp</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>nreplace</declname>
        </param>
        <briefdescription>
<para>Make a replacement of regex matches, ignoring captured substrings. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Characer pointer to buffer that replacements should be made to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len_buf</parametername>
</parameternamelist>
<parameterdescription>
<para>const size_t length of buf. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">re</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant character pointer to regex string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rp</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant character pointer to the replacement text. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nreplace</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant size_t number of replacements to make. If 0, all matches are replaced. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int -1 on failure if the regex could not be compiled or the buffer is not big enough to contain the result. If succesful, the new length of buf is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="110" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="110" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="regex__win32_8cpp_1aeaadd6a094afc86d5c7ace1dd05dd621" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int get_subrefs</definition>
        <argsstring>(const char *buf, size_t **refs)</argsstring>
        <name>get_subrefs</name>
        <param>
          <type>const char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t **</type>
          <declname>refs</declname>
        </param>
        <briefdescription>
<para>Extract substring references from a string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant character pointer to buffer that references should be extracted from. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">refs</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to pointer to memory where reference numbers should be stored. This function will reallocate it to fit the number of references returned. (Should be freed by calling program.) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int Number of refs found. -1 indicates an error. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="169" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="169" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="regex__win32_8cpp_1a496a196408e1ed1605f741e791f6d109" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int regex_replace_sub</definition>
        <argsstring>(char *buf, const size_t len_buf, const char *re, const char *rp, const size_t nreplace)</argsstring>
        <name>regex_replace_sub</name>
        <param>
          <type>char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>len_buf</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>re</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>rp</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>nreplace</declname>
        </param>
        <briefdescription>
<para>Make a replacement of regex matches, allowing for captured substrings. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Characer pointer to buffer that replacements should be made to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len_buf</parametername>
</parameternamelist>
<parameterdescription>
<para>const size_t length of buf. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">re</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant character pointer to regex string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rp</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant character pointer to the replacement text. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nreplace</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant size_t number of replacements to make. If 0, all matches are replaced. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int -1 on failure if the regex could not be compiled or the buffer is not big enough to contain the result. If succesful, the new length of buf is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" line="254" column="1" bodyfile="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp" bodystart="254" bodyend="338"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;regex&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdint&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;regex_win32.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::regex_iterator&lt;const<sp/>char<sp/>*&gt;<sp/>Myiter;</highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count_matches(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*regex_text,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*to_match)<sp/>{</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="21"><highlight class="normal"><sp/><sp/><sp/><sp/>Myiter::regex_type<sp/>r(regex_text);</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/>Myiter<sp/>next(to_match,<sp/>to_match<sp/>+<sp/>strlen(to_match),<sp/>r);</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/>Myiter<sp/>end;</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>next<sp/>!=<sp/>end;<sp/>++next)</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ret++;</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="31"><highlight class="normal">}</highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>find_matches(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*regex_text,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*to_match,</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>**sind,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>**eind)<sp/>{</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>std::regex<sp/>r(regex_text);</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cmatch<sp/>m;</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(regex_search(to_match,<sp/>to_match<sp/>+<sp/>strlen(to_match),<sp/>m,<sp/>r))<sp/>{</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>+=<sp/>m.size();</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*sind<sp/>=<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*)realloc(*sind,<sp/>ret*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*eind<sp/>=<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*)realloc(*eind,<sp/>ret*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ret;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/>(*sind)[i]<sp/>=<sp/>m.position(i);</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/>(*eind)[i]<sp/>=<sp/>(*sind)[i]<sp/>+<sp/>m.length(i);</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="65"><highlight class="normal">}</highlight></codeline>
<codeline lineno="66"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>find_match(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*regex_text,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*to_match,</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*sind,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*eind)<sp/>{</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/>std::regex<sp/>r(regex_text);</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cmatch<sp/>m;</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(regex_search(to_match,<sp/>to_match<sp/>+<sp/>strlen(to_match),<sp/>m,<sp/>r))<sp/>{</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ret++;</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*sind<sp/>=<sp/>m.position();</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*eind<sp/>=<sp/>*sind<sp/>+<sp/>m.length();</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="94"><highlight class="normal">}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>regex_replace_nosub(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buf,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len_buf,</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*re,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*rp,</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nreplace)<sp/>{</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/>std::regex<sp/>r(re);</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len_rp<sp/>=<sp/>strlen(rp);</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len_m,<sp/>rem_s,<sp/>rem_l,<sp/>delta_siz;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>cur_pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>cur_siz<sp/>=<sp/>strlen(buf);</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>creplace<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cmatch<sp/>m;</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((nreplace<sp/>&gt;<sp/>0)<sp/>&amp;&amp;<sp/>(creplace<sp/>&gt;=<sp/>nreplace))<sp/>{</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;regex_replace_nosub:<sp/>Maximum<sp/>of<sp/>%d<sp/>replacements<sp/>reached\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)creplace);</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*first<sp/>=<sp/>buf<sp/>+<sp/>cur_pos;</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*last<sp/>=<sp/>buf<sp/>+<sp/>cur_siz;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(regex_search(first,<sp/>last,<sp/>m,<sp/>r)))<sp/>{</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ensure<sp/>replacement<sp/>will<sp/>not<sp/>exceed<sp/>buffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>len_m<sp/>=<sp/>m.length();</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>delta_siz<sp/>=<sp/>len_rp<sp/>-<sp/>len_m;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((cur_siz<sp/>+<sp/>delta_siz<sp/>+<sp/>1)<sp/>&gt;<sp/>len_buf)<sp/>{</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;regex_replace_nosub:<sp/>Relacement<sp/>will<sp/>exceed<sp/>buffer.\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/>cur_siz<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>trailing</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rem_l<sp/>=<sp/>cur_siz<sp/>-<sp/>(cur_pos<sp/>+<sp/>m.position()<sp/>+<sp/>len_m);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rem_s<sp/>=<sp/>m.position()<sp/>+<sp/>len_rp;</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*p<sp/>=<sp/>buf<sp/>+<sp/>cur_pos;</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memmove(p<sp/>+<sp/>rem_s,<sp/>p<sp/>+<sp/>m.position()<sp/>+<sp/>len_m,<sp/>rem_l<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Copy<sp/>replacement</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>strncpy(p<sp/>+<sp/>m.position(),<sp/>rp,<sp/>len_rp);</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Advance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cur_pos<sp/>+=<sp/>rem_s;</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cur_siz<sp/>+=<sp/>delta_siz;</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>creplace<sp/>+=<sp/>1;</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>printf(&quot;regex_replace_nosub()<sp/>=<sp/>%s\n&quot;,<sp/>buf);<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cur_siz;</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="158"><highlight class="normal">}</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline lineno="169"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>get_subrefs(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buf,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>**refs)<sp/>{</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compile</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>check<sp/>this<sp/>on<sp/>windows<sp/>regex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>std::regex<sp/>r(</highlight><highlight class="stringliteral">&quot;\\$([[:digit:]])&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Prepare<sp/>&quot;bitmap&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>max_ref<sp/>=<sp/>10;<sp/></highlight><highlight class="comment">//99;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>*ref_bytes<sp/>=<sp/>(uint8_t*)malloc((max_ref<sp/>+<sp/>1)*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint8_t));</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/>max_ref;<sp/>i++)</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ref_bytes[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cmatch<sp/>m;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>max_grp<sp/>=<sp/>2;<sp/><sp/></highlight><highlight class="comment">//<sp/>Digits<sp/>in<sp/>max_ref</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>igrp_len;</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>igrp[max_grp];</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>iref;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*first<sp/>=<sp/>buf;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*last<sp/>=<sp/>buf<sp/>+<sp/>strlen(buf);</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(regex_search(first,<sp/>last,<sp/>m,<sp/>r)))<sp/>{</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Lone<sp/>$<sp/>without<sp/>digit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>printf(&quot;so<sp/>=<sp/>%d,<sp/>eo<sp/>=<sp/>%d\n&quot;,<sp/>(int)m[1].rm_so,<sp/>(int)m[1].rm_eo);<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m.size()<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/>first<sp/>+=<sp/>m.position()<sp/>+<sp/>m.length();</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Substring</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>igrp_len<sp/>=<sp/>m.length(1);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(igrp_len<sp/>&gt;<sp/>max_grp)<sp/>{</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Number<sp/>longer<sp/>than<sp/>%d<sp/>digits<sp/>unlikely.\n&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)max_grp);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ref_bytes);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>strncpy(igrp,<sp/>first<sp/>+<sp/>m.position(1),<sp/>igrp_len);</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>igrp[igrp_len]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>ref<sp/>number</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>iref<sp/>=<sp/>atoi(igrp);</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iref<sp/>&gt;<sp/>max_ref)<sp/>{</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Reference<sp/>to<sp/>substr<sp/>%d<sp/>exceeds<sp/>limit<sp/>(%d)\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)iref,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)max_ref);</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ref_bytes);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ref_bytes[iref]<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>first<sp/>+=<sp/>m.position()<sp/>+<sp/>m.length();</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>unique<sp/>refs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nref<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/>max_ref;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ref_bytes[i])</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>nref++;</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/>*refs<sp/>=<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*)realloc(*refs,<sp/>nref*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>ir;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0,<sp/>ir<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/>max_ref;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ref_bytes[i])<sp/>{</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>(*refs)[ir]<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/>ir++;</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ref_bytes);</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;%d<sp/>refs<sp/>in<sp/>%s\n&quot;,<sp/>nref,<sp/>buf);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>nref;</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="238"><highlight class="normal">}</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>regex_replace_sub(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buf,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len_buf,</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*re,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*rp,</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nreplace)<sp/>{</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compile</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>std::regex<sp/>r(re);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Loop<sp/>making<sp/>replacements</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cmatch<sp/>m;</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*rp_sub<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)malloc(2*len_buf*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*re_sub<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)malloc(len_buf*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*igrp<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)malloc(len_buf*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len_m,<sp/>rem_s,<sp/>rem_l,<sp/>delta_siz,<sp/>len_rp;</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>cur_pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>cur_siz<sp/>=<sp/>strlen(buf);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>creplace<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((nreplace<sp/>&gt;<sp/>0)<sp/>&amp;&amp;<sp/>(creplace<sp/>&gt;=<sp/>nreplace))<sp/>{</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;regex_replace_nosub:<sp/>Maximum<sp/>of<sp/>%d<sp/>replacements<sp/>reached\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)creplace);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*first<sp/>=<sp/>buf<sp/>+<sp/>cur_pos;</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*last<sp/>=<sp/>buf<sp/>+<sp/>cur_siz;</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(regex_search(first,<sp/>last,<sp/>m,<sp/>r)))<sp/>{</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>printf(&quot;regex_replace_sub:<sp/>nomatch<sp/>for<sp/>%s<sp/>in<sp/>%s\n&quot;,<sp/>re,<sp/>p);<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>list<sp/>of<sp/>subrefs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*refs<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nref<sp/>=<sp/>get_subrefs(rp,<sp/>&amp;refs);</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nref<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Error<sp/>gettings<sp/>subrefs\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/>cur_siz<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>each<sp/>subref<sp/>complete<sp/>replacements</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(rp_sub,<sp/>rp);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>nref;<sp/>j++)<sp/>{</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>refs[j];</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/>strcpy(igrp,<sp/>buf<sp/>+<sp/>cur_pos<sp/>+<sp/>m.position(i));</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/>igrp[m.length(i)]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">//<sp/>terminate</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/>sprintf(re_sub,<sp/></highlight><highlight class="stringliteral">&quot;\\$%d&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)i);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>regex_replace_nosub(rp_sub,<sp/>2*len_buf,<sp/>re_sub,<sp/>igrp,<sp/>0);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;regex_replace_sub:<sp/>Error<sp/>replacing<sp/>substring<sp/>$%d.\n&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)i);</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(refs);</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(rp_sub);</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(re_sub);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(igrp);</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ensure<sp/>replacement<sp/>will<sp/>not<sp/>exceed<sp/>buffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>len_rp<sp/>=<sp/>ret;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>len_m<sp/>=<sp/>m.length();</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>delta_siz<sp/>=<sp/>len_rp<sp/>-<sp/>len_m;</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((cur_siz<sp/>+<sp/>delta_siz<sp/>+<sp/>1)<sp/>&gt;<sp/>len_buf)<sp/>{</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;regex_replace_sub:<sp/>Relacement<sp/>will<sp/>exceed<sp/>buffer.\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/>cur_siz<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>trailing</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rem_l<sp/>=<sp/>cur_siz<sp/>-<sp/>(cur_pos<sp/>+<sp/>m.position()<sp/>+<sp/>m.length());</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rem_s<sp/>=<sp/>m.position()<sp/>+<sp/>len_rp;</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memmove(buf<sp/>+<sp/>cur_pos<sp/>+<sp/>rem_s,</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>buf<sp/>+<sp/>cur_pos<sp/>+<sp/>m.position()<sp/>+<sp/>m.length(),<sp/>rem_l<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Copy<sp/>replacement</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>strncpy(buf<sp/>+<sp/>cur_pos<sp/>+<sp/>m.position(),<sp/>rp_sub,<sp/>len_rp);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Advance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cur_pos<sp/>+=<sp/>m.position()<sp/>+<sp/>len_rp;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cur_siz<sp/>+=<sp/>delta_siz;</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>creplace<sp/>+=<sp/>1;</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(refs);</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/>free(rp_sub);</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/>free(re_sub);</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/>free(igrp);</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cur_siz;</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::regex_error&amp;<sp/>rerr)<sp/>{</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="338"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/root/cis_interface/cis_interface/cis_interface/regex/regex_win32.cpp"/>
  </compounddef>
</doxygen>
